# Chapter 15. GraalVM Native Image Support

GraalVM Native Images are standalone executables that can be generated by processing compiled Java applications ahead-of-time. 

GraalVM Native Images 是独立的可执行文件，可以通过预先处理已编译的Java应用程序生成。

Native Images generally have a smaller memory footprint and start faster than their JVM counterparts.

Native Images 通常具有较小的内存占用，并且启动速度比 JVM 快。

- memory footprint  n. 占用空间

## 15.1. Introducing GraalVM Native Images

GraalVM Native Images provide a new way to deploy and run Java applications. 

Compared to the Java Virtual Machine, native images can run with a smaller memory footprint and with much faster startup times.

They are well suited to applications that are deployed using container images and are especially interesting when combined with "Function as a service" (FaaS) platforms.

- be suited to 适用于 

Unlike traditional applications written for the JVM, GraalVM Native Image applications require ahead-of-time processing in order to create an executable.

- executable 可执行文件

 This ahead-of-time processing involves statically analyzing your application code from its main entry point.


- involve v. 涉及

- statically  adv. 静态地；静止地

A GraalVM Native Image is a complete, platform-specific executable. You do not need to ship a Java Virtual Machine in order to run a native image.

- platform-specific 特定平台平台特性特定于平台的

### 15.1.1. Key Differences with JVM Deployments#

The fact that GraalVM Native Images are produced ahead-of-time means that there are some key differences between native and JVM based applications. 

The main differences are:

- Static analysis of your application is performed at build-time from the main entry point.

- Code that cannot be reached when the native image is created will be removed and won’t be part of the executable.

- GraalVM is not directly aware of dynamic elements of your code and must be told about reflection, resources, serialization, and dynamic proxies.

- The application classpath is fixed at build time and cannot change.

- There is no lazy class loading, everything shipped in the executables will be loaded in memory on startup.

- There are some limitations around some aspects of Java applications that are not fully supported.

### 15.1.2. Understanding Spring Ahead-of-Time Processing

Typical Spring Boot applications are quite dynamic and configuration is performed at runtime. 

In fact, the concept of Spring Boot auto-configuration depends heavily on reacting to the state of the runtime in order to configure things correctly.

Although it would be possible to tell GraalVM about these dynamic aspects of the application, doing so would undo most of the benefit of static analysis. 

尽管可以将应用程序的这些动态方面告诉GraalVM，但这样做会抵消静态分析的大部分好处。

 - undo v. 撤销（先前的计算机指令）

 So instead, when using Spring Boot to create native images, a closed-world is assumed and the dynamic aspects of the application are restricted.

因此，当使用Spring Boot创建本机映像时，假定是一个封闭的世界，并且应用程序的动态方面受到限制。

A closed-world assumption implies the following restrictions:

- The classpath is fixed and fully defined at build time

- The beans defined in your application cannot change at runtime, meaning:
  - The Spring `@Profile` annotation and profile-specific configuration is not supported
  - Properties that change if a bean is created are not supported (for example, `@ConditionalOnProperty` and `.enable` properties).

When these restrictions are in place, it becomes possible for Spring to perform ahead-of-time processing during build-time and generate additional assets that GraalVM can use.

- be in place 在原位，得其所，在应有的位置上

A Spring AOT processed application will typically generate:

Spring AOT处理的应用程序通常会生成:

- Java source code

- Bytecode (for dynamic proxies etc)

- GraalVM JSON hint files:

  - Resource hints (`resource-config.json`)

  - Reflection hints (`reflect-config.json`)

  - Serialization hints (`serialization-config.json`)

  -   Java Proxy Hints (`proxy-config.json`)

  -   JNI Hints (`jni-config.json`)

**Source Code Generation**

Spring applications are composed of Spring Beans. 

Internally, Spring Framework uses two distinct concepts to manage beans.

在内部，Spring Framework使用两个不同的概念来管理bean。

There are bean instances, which are the actual instances that have been created and can be injected into other beans.

有bean实例，它们是已经创建的实际实例，可以注入到其他bean中。

There are also bean definitions which are used to define attributes of a bean and how its instance should be created.

还有一些bean定义，用于定义bean的属性以及应该如何创建它的实例。

If we take a typical `@Configuration` class:

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration(proxyBeanMethods = false)
public class MyConfiguration {

    @Bean
    public MyBean myBean() {
        return new MyBean();
    }

}
```

The bean definition is created by parsing the `@Configuration` class and finding the `@Bean` methods. 

- parse vt. 解析；

In the above example, we're defining a `BeanDefinition` for a singleton bean named `myBean`. We're also creating a `BeanDefinition` for the `MyConfiguration` class itself.

When the `myBean` instance is required, Spring knows that it must invoke the `myBean()` method and use the result.

When running on the JVM,, `@Configuration` class parsing happens when your application starts and `@Bean` methods are invoked using reflection.

When creating a native images, Spring operates in a diffrent way. 

Rather than parsing `@Configuration` classes and generating bean definitions at runtime, it does it at build-time. 

它不是在运行时解析“@Configuration”类并生成bean定义，而是在构建时进行。

Once the bean definitions have been discovered, they are processed and converted into source code that can be analyzed by the GraalVM compiler.

The Spring AOT process would convert the configuration class above to code like this:

```java
import org.springframework.beans.factory.aot.BeanInstanceSupplier;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.RootBeanDefinition;

/**
 * Bean definitions for {@link MyConfiguration}.
 */
public class MyConfiguration__BeanDefinitions {

    /**
     * Get the bean definition for 'myConfiguration'.
     */
    public static BeanDefinition getMyConfigurationBeanDefinition() {
        Class<?> beanType = MyConfiguration.class;
        RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);
        beanDefinition.setInstanceSupplier(MyConfiguration::new);
        return beanDefinition;
    }

    /**
     * Get the bean instance supplier for 'myBean'.
     */
    private static BeanInstanceSupplier<MyBean> getMyBeanInstanceSupplier() {
        return BeanInstanceSupplier.<MyBean>forFactoryMethod(MyConfiguration.class, "myBean").withGenerator(
                (registeredBean) -> registeredBean.getBeanFactory().getBean(MyConfiguration.class).myBean());
    }

    /**
     * Get the bean definition for 'myBean'.
     */
    public static BeanDefinition getMyBeanBeanDefinition() {
        Class<?> beanType = MyBean.class;
        RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);
        beanDefinition.setInstanceSupplier(getMyBeanInstanceSupplier());
        return beanDefinition;
    }

}
```

You can see above that the generated code creates equivalent bean definitions to the `@Configuration` class, but in a direct way that can be understood by GraalVM.

There is a bean definition for the `myConfiguration` bean, and one for `myBean`.

When a `myBean` instance is required, a `BeanInstanceSupplier` is called. This supplier will invoke the `myBean()` method on the `myConfiguration` bean.

Spring AOT will generate code like this for all your bean definitions.

It will also generate code when bean post-processing is required (for example, to call `Autowired` mothods). 

An `ApplicationContextInitialized` will also be generated which will be used by Spring Boot to initialized the `ApplicationContext` when an AOT processed application is actually run.

还会生成一个' ApplicationContextInitialized '，当AOT处理的应用程序实际运行时，Spring Boot将使用它初始化' ApplicationContext '。

**Hint File Generation**

In addition to generating source files, the Spring AOT engine will also generate hint files that are used by GraalVM.

- in addition to 除...之外（还有，也）

- hint n. 暗示，提示；征兆，迹象；少许，少量；秘诀，窍门

Hint files contain JSON data that describes how GraalVm should deal with things that it can't understand by directly inspecting the code.

提示文件包含JSON数据，描述GraalVm应该如何通过直接检查代码来处理它无法理解的事情。

For example, you might be using a Spring annotation on a private method.

Spring will need to use reflection in order to invoke private methods, even on GraalVM.

- even on GraalVM 即使在GraalVM

When such situation arise, Spring can write a reflection hint so that GraalVM knows that even though the private method isn't called directly, it still needs to be available in the native image.

- When such situation arise 当这种情况出现时

Hint files are genrated under `META-INF/native-image` where they are automatically picked up by GraalVM.

**### 1.2.3. **Proxy Class Generation**

Spring sometimes needs to generate proxy classes to enhance the code you're written with additional featured. To do this, it uses the cglib library which directly generates bytecode.

When an application is running on the JDK, proxy classes are generated dynamically as the application runs.

When creating a native image, thses proxies need to be create at build-time so that they can be included by GraalVM.

## 15.2. Developing Your First GraalVM Native Application

Now that we have a good overview of GraalVM Native Images and how the Spring ahead-of-time engine works, we can look at how to create an application.

There are two main ways to build a Spring Boot native image application:

- Using Spring Boot support for Cloud Native Buildpacks to generate a light weight container containing a native executable.

- 使用Spring Boot对Cloud Native Buildpacks的支持来生成包含本机可执行文件的轻量级容器。
- Using GraalVM Native Build Tools to generate a native executable.

> Tip
> The easiest way to start a new native Spring Boot project is to go to `start.spring.io`, add the "GraalVM Native Support" dependency and generate the project. The included `HELP.md` file will provide getting started hints.
>

### 15.2.1. Sample Application

We need an example application that we can use to create our native image. 

For our purpose, the simple "Hello World!" web application that's covered in the "getting-started.html" section will suffice.

- suffice v. 足够，足以；满足……的需求；有能力

To recap, our main application code looks like this:

- recap v. 扼要重述，摘要说明；翻新胎面

概括一下，我们的主应用程序代码如下:

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
@RestController
@SpringBootApplication
public class MyApplication {
  @RequestMapping("/")
  String home() {
  return "Hello World!";
  }
  public static void main(String[] args) {
  SpringApplication.run(MyApplication.class, args);
  }
}
```

This application uses Spring MVC and embedded Tomcat, both of which have been tested and verified to work with GraalVM native images.

这个应用程序使用Spring MVC和嵌入式Tomcat，这两者都经过了测试和验证，可以与GraalVM本机映像一起工作。


### 15.2.2. Building a Native Image Using Buildpacks

Spring Boot includes buildpack support for native images directly for both Maven and Gradle. 

This means you can just type a single command and quickly get a sensible image into your locally running Docker daemon.

The resulting image doesn't contain a JVM, instead the native image is compiled statically. This leads to smaller images.

- statically adv. 静态地；静止地 

> The builder used for the images is `paketobuildpacks/builder:tiny.` It has small footprint and reduced surface attack, but you can also use `paketobuildpacks/builder:base` or `paketobuildpacks/builder:full` to have more tools available in the image if required.

**System Requirements**

Docker should be installed, see [Get Docker](https://docs.docker.com/installation/#installation) for more details. [Configure it to allow non-root user](https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user) if you are on Linux.

**Using Maven**

To build a native image container using Maven you should ensure that your pom.xml file uses the `spring-boot-starter-parent`. You should have a `<parent>` section that looks like this:

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.0.0</version>
</parent>
```

The `spring-boot-starter-parent` declares a `native` profile that configures the executions that need to run in order to create a native image. You can activate profiles using the `-P` flag on the command line.

To build the image, you can run the `spring-boot:build-image` goal with the `native` profile active:

```shell
$ mvn -Pnative spring-boot:build-image
```

**Using Gradle**

The Spring Boot Gradle plugin automatically configures AOT tasks when the GraalVM Native Image plugin is applied. 

You should check that your gradle build contains a `plugins` block that includes `org.graalvm.buildtools.native`.

As long as the org.graalvm.buildtools.native plugin is applied, the `bootBuildImage` task will generate a native image rather than a JVM one. You can run the task using:

- As long as the org.graalvm.buildtools.native plugin is applied
  
- 只要应用org.graalvm.buildtools.native插件

```shell
$ gradle bootBuildImage
```

**Running the example**

Once you have run the appropriate build command, a Docker image should be available. You can start your application using `docker run`:

```shell
$ docker run --rm -p 8080:8080 docker.io/library/myproject:0.0.1-SNAPSHOT
```

You should see output similar to the following:

If you open a web browser to localhost:8080, you should see the following output:

```
Hello World!
```

To gracefully exit the application, press ctrl-c.

### 15.2.3. Building a Native Image using Native Build Tools

If you want to generate a native executable directly without using Docker, you can use GraalVM Native Build Tools. 

Native Build Tools are plugins shipped by GraalVM for both Maven and Gradle. 

You can use them to perform a variety of GraalVM tasks, including generating a native image.

**Prerequisites**

To build a native image using the Native Build Tools, you’ll need a GraalVM distribution on your machine. 

You can either download it manually on the `Liberica Native Image Kit page`, or you can use a download manager like SDKMAN!.

**Linux and MacOS**

To install the native image compiler on MacOS or Linux, we recommend using SDKMAN!. 

Get SDKMAN! from `sdkman.io` and install the Liberica GraalVM distribution by using the following commands:

```shell
$ sdk install java 22.3.r17-nik
$ sdk use java 22.3.r17-nik
```

Verify that the correct version has been configured by checking the output of java -version:

**Windows**

On Windows, follow [these instructions](https://medium.com/graalvm/using-graalvm-and-native-image-on-windows-10-9954dc071311) to install either `GraalVM` or `Liberica Native Image Kit` in version 22.3, the Visual Studio Build Tools and the Windows SDK.

Due to the `Windows related command-line maximum length`, make sure to use x64 Native Tools Command Prompt instead of the regular Windows command line to run Maven or Gradle plugins.

**Using Maven**

As with the `buildpack support`, you need to make sure that you’re using `spring-boot-starter-parent` in order to inherit the `native` profile.

With the native profile active, you can invoke the `native:compile` goal to trigger `native-image` compilation:

```shell
$ mvn -Pnative native:compile
```

The native image executable can be found in the `target` directory.

**Using Gradle**

When the Native Build Tools Gradle plugin is applied to your project, the Spring Boot Gradle plugin will automatically trigger the Spring AOT engine. 

Task dependencies are automatically configured, so you can just run the standard `nativeCompile` task to generate a native image:

```
$ gradle nativeCompile
```

The native image executable can be found in the `build/native/nativeCompile` directory.

### 2.3.4. Running the Example

At this point, your application should work, you can now start the application by running it directly:

```shell
$ target/myproject
```

# 3. Testing GraalVM Native Images

When writing native image applications, we recommend that you continue to use the JVM whenever possible to develop the majority of your unit and integration tests. 

在编写本机映像应用程序时，我们建议您尽可能继续使用JVM来开发大部分单元和集成测试。

 This will help keep developer build times down and allow you to use existing IDE integrations. 

 With broad test coverage on the JVM, you can then focus native image testing on the areas that are likely to be different.

 For native image testing, you’re generally looking to ensure that the following aspects work:

 - The Spring AOT engine is able to process your application and will it run in an AOT-processed mode.
 - GraalVM has enough hints to ensure that a valid native image can be produced.

### 15.3.1. Testing Ahead-of-time Processing With the JVM

When a Spring Boot application runs, it attempts to detect if it is running as a native image. 

-  attempt v. 努力，尝试

If it is running as a native image, it will initialize the application using the code that was generated during at build-time by the Spring AOT engine.

If the application is running on a regular JVM, then any AOT generated code is ignored.

Since the `native-image` compilation phase can take a while to complete, it’s sometimes useful to run your application on the JVM but have it use the AOT generated initialization code. 

由于本机映像编译阶段可能需要一段时间才能完成，因此有时在JVM上运行应用程序，但让它使用AOT生成的初始化代码是很有用的。

Doing so helps you to quickly validate that there are no errors in the AOT generated code and nothing is missing when your application is eventually converted to a native image.

To run a Spring Boot application on the JVM and have it use AOT generated code you can set the `spring.aot.enabled` system property to `true`.

For example:

```shell
java -Dspring.aot.enabled=true -jar myapplication.jar
```

> You need to ensure that the jar you are testing includes AOT generated code. For Maven, this means that you should build with -Pnative to active the native profile.
> For Gradle, you need to ensure that your build includes the `org.graalvm.buildtools.native` plugin.

If your application starts with the `spring.aot.enabled` property set to true, then you have higher confidence that it will work when converted to a native image.

You can also consider running integration tests against the running application. 

For example, you could use the Spring `WebClient` to call your application REST endpoints. 

Or you might consider using a project like Selenium to check your applications HTML responses.

### 15.3.2. Testing With Native Build Tools

GraalVM Native Build Tools includes the ability to run tests inside a native image.

This can be helpful when you want to deeply test that the internals of you application work in a GraalVM native image.

Generating the native image that contains the tests to run can be a time-consuming operation, so most developers will probably prefer to use the JVM locally. 

They can, however, be very useful as part of a CI pipeline. For example, you might choose to run native tests once a day.

Spring Framework includes ahead-of-time support for running tests.

 All the usual Spring testing features work with native image tests. 


 For example, you can continue to use the `@SpringBootTest` annotation. 
 
 You can also use Spring Boot test slices to test only specific parts of your application.

 - slice v. 把……切成薄片；切，割，划；轻易快速穿过（空气或水等）；削（球），斜切打；（无意中）打出弧线球；减少（时间、钱等）

Spring Framework’s native testing support works in the following way:

- Test are analyzed in order to discover any `ApplicationContext` instances that will be required.
- Ahead-of-time processing is applied to each of these application contexts and assets are generated.
- A native image is created, with the generated assets being processed by GraalVM.
- The native image also includes the JUnit `TestEngine` configured with a list of the discovered tests.
- The native image is started, triggering the engine which will run each test and report results.

**Using Maven**

To run native tests using Maven, ensure that your `pom.xml `file uses the `spring-boot-starter-parent`. You should have a `<parent>` section that looks like this:

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.0.0</version>
</parent>
```

The `spring-boot-starter-parent` declares a `nativeTest` profile that configures the executions that are needed to run the native tests. You can activate profiles using the `-P` flag on the command line.

To build the image and run the tests, use the `test` goal with the `nativeTest` profile active:

```shell
$ mvn -PnativeTest test
```

**Using Gradle**

The Spring Boot Gradle plugin automatically configures AOT test tasks when the GraalVM Native Image plugin is applied. 

You should check that your gradle build contains a `plugins` block that includes `org.graalvm.buildtools.native`.

To run native tests using Gradle you can use the `nativeTest` task:

```shell
gradle nativeTest
```

## 15.4. Advanced Native Images Topics

### 15.4.1. Nested Configuration Properties

### 15.4.2. Converting a Spring Boot Executable Jar

### 15.4.3. Using the Tracing Agent

### 15.4.4. Custom Hints

**Testing custom hints**

## 15.4.5. Known Limitations

# 5. What to Read Next

If you want to learn more about the ahead-of-time processing provided by our build plugins, see the Maven and Gradle plugin documentation. 

To learn more about the APIs used to perform the processing, browse the `org.springframework.aot.generate` and `org.springframework.beans.factory.aot` packages of the Spring Framework sources.

For known limitations with Spring and GraalVM, please see the Spring Boot wiki.

The next section goes on to cover the Spring Boot CLI.