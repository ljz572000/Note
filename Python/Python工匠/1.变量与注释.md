# 变量与注释

## 1.1 基础知识

### 1.1.1

变量与注释是作者表达思想的基础，是读者理解代码的第一道门，它们对代码质量的贡献毋庸置疑

#### 01. 变量解包

变量**解包**（unpacking）： 是 Python 里的一种特殊赋值操作，允许我们把一个可迭代对象（比如列表）的所有成员，一次性赋值给多个变量：

```python
>>> usernames = ['piglei', 'raymond']
# 注意：左侧变量的个数必须和待展开的列表长度相等，否则会报错
>>> author, reader = usernames
>>> author
'piglei'
```

甚至可以一次展开多层嵌套数据：

```python
>>> attrs = [1, ['piglei', 100]]
>>> user_id, (username, score) = attrs
>>> user_id
1
>>> username
'piglei'
```

除了上面的普通解包外，Python 还支持更灵活的动态解包语法。

只要用星号表达式（\*variables）作为变量名，它便会贪婪地捕获多个值对象，并将捕获到的内容作为列表赋值给 variables。

```python
>>> data = ['piglei', 'apple', 'orange', 'banana', 100]
>>> username, *fruits, score = data
>>> username
'piglei'
>>> fruits
['apple', 'orange', 'banana']
>>> score
100
```

和常规的切片赋值语句比起来，动态解包语法要直观许多

上面的变量解包操作也可以在任何循环语句里使用：

```python
>>> for username, score in [('piglei', 100), ('raymond', 60)]:
...     print(username)
...
piglei
raymond
```

#### 02. 单下划线变量名\_

在常用的诸多变量名中，单下划线\_是比较特殊的一个。

它常作为一个无意义的占位符出现在赋值语句中。

\_这个名字本身没什么特别之处，这算是大家约定俗成的一种用法。

```python
#忽略展开时的第二个变量
>>> author, _ = usernames
# 忽略第一个和最后一个变量之间的所有变量
>>> username, *_, score = data
```

### 1.1.2 给变量注明类型

```python
def remove_invalid(items):
    """剔除 items 里面无效的元素"""
    ... ...
```

从上面代码中，我们无法得知，items 参数是什么类型。

为了解决动态类型带来的可读性问题，最常见的办法就是在函数文档（docstring）里做文章。我们可以把每个函数参数的类型与说明全都写在函数文档里。

下面是增加了 Python 官方推荐的 Sphinx 格式文档后的效果：

```Python
def remove_invalid(items):
    """剔除 items 里面无效的元素

    :param items: 待剔除对象
    :type items: 包含整数的列表，[int, ...]
    """
```

在上面的函数文档里，注明了。任何人只要读到这份文档，马上就能知道参数类型。

当然，标注类型的办法肯定不止上面这一种。

在 python 3.5 版本以后，你可以用类型注解功能来直接注明变量类型。

**相比编写 Sphinx 格式文档，我其实更推荐使用类型注解，因为它是 Python 内置功能，而且正在变得越来越流行**。

```Python
from typing import List

def remove_invalid(items: List[int]): ➊
    """剔除 items 里面无效的元素"""
    ... ...
```

> List 表示参数为列表类型，`[int]` 表示里面的成员是整型

> "类型注解"只是一种有关类型的注释，不提供任何校验功能。要校验类型正确性，需要使用其他静态类型检查工具（如 mypy 等）。

平心而论，不管是编写 Sphinx 格式文档，还是添加类型注释，都会增加编写代码的工作量。

同样一段代码，标注变量类型比不标注一定要花费更多时间。

但从我的经验来看，这些额外的时间投入，会带来非常丰厚的回报

- 代码更已读
- 大部分 IDE 会读取类型注解信息，提供更智能的输入提示；
- 类型注解配合 mypy 等静态类型检查工具，能提升代码正确性

### 1.1.3 变量命名原则

#### 01. 遵循 PEP 8 原则

给变量起名主要有两种流派：

1. 通过大小写界定单词的驼峰命名派 CamelCase
2. 通过下划线连接的蛇形命名派 snake_case

为了让不同开发者写出代码风格尽量保持统一，Python 制定了官方的编码风格指南：PEP 8.

这份风格指南里有许多详细的风格建议，

比如应该用 4 个空格缩进，每行不超过 79 个字符，等等

#### 02. 描述性要强

在可接受的长度范围内，变量名所指向的内容描述得越精确越好。

```python
#描述性弱的名字：看不懂在做什么
value = process(s.strip())
# 描述性强的名字：尝试从用户输入里解析出一个用户名
username = extract_username(input_string.strip())
```

#### 03. 要尽量短

为变量命名要结合代码情景和上下文。

即使没用特别长的名字，相信读代码的人也肯定能明白

#### 04. 要匹配类型

虽然变量无须声明类型，但是为了提升可读性，我们可以用类型注解语法给其加上类型。

大部分 Python 项目 没有类型注解，因此当你看到一个变量时，除了通过上下文猜测，没法轻易知道它是什么类型。

**Boolean**

| 变量名       | 含义           | 说明        |
| ------------ | -------------- | ----------- |
| is_superuser | 是否是超级用户 | 是/不是     |
| has_errors   | 有没有错误     | 有/没有     |
| allow_empty  | 是否允许空值   | 允许/不允许 |

**匹配int/float类型的变量名**

- 释义为数字的所有单词，比如port(端口号)、age、radius;
- 使用以_id结尾的单词，比如user_id、host_id;
- 使用以length/count开头或者结尾的单词，比如max_length

**匹配其他类型的变量名**

至于剩下的字符串（str）、列表（list）、字典（dict ）等其他值类型，强烈建议在代码中明确标注它们的类型详情。

#### 05.超短命名

在众多变量名里，有一类非常特别，那就是只有一两个字母的短名字。

这些短名字一般可分为两类，一类是那些大家约定俗成的短名字，比如

- 数组索引三剑客i、j、k
- 某个整数n
- 某个字符串s
- 某个异常e
- 文件对象fp

不反对使用这类短名字，但如果条件允许，建议尽量用更精确的名字代替。

另一类短名字，则是对一些其他常用名的缩写

在Django框架做国际化内容翻译时，常常会用到gettext方法。为了方便，常缩写成_:

```python
from django.utils.translation import gettext as _
print(_('待翻译文字'))
```

但是同一个项目内的超短缩写不宜太多，否则会适得其反

#### 其他技巧

- 在同一段代码内，不要出现多个相似的变量名，比如同时使用users、users1、users3这种序列；
- 可以尝试换词来简化复合变量名，比如用is_special来代替is_not_normal;
- 如果你苦思冥想都想不出来一个合适的名字，请打开Github, 到其他人的项目里找找灵感。

### 1.1.4 注释其他知识

注释（comment）是代码非常重要的组成部分。

通常来说，注释泛指那些不影响代码实际行为的文字，它们主要起额外说明作用。

单行注释

```python
#用户输入可能会有空格，使用strip去掉空格
username = extract_username(input_string.strip())
```

多行注释

```python
#使用strip()去掉空格的好处：
# 1. 数据库保存时占用空间更小
# 2. 不必因为用户多打了一个空格而要求用户重新输入
username = extract_username(input_string.strip())
```

接口注释

函数（类）文档（docstring）,这些文档也称接口注释

```python
class Person:
    """人

    :param name: 姓名
    :param age: 年龄
    :param favorite_color: 最喜欢的颜色
    """

    def __init__(self, name, age, favorite_color):
        self.name = name
        self.age = age
        self.favorite_color = favorite_color
```

接口注释风格有好几种。Sphinx文档风格、Google风格等。

其中Sphinx风格最为流行

**新手常见编写注释错误**

01. 用注释屏蔽代码

有时，人们会把注释当作临时屏蔽代码的工具。当某些代码暂时不需要执行时，就把它们都注释了，未来需要时再解除注释。

其实根本没必要这么做。这些被临时注释掉的大段内容，对于阅读代码的人来说是一种干扰，没有任何意义。

对于不再需要的代码，我们应该直接把它们删掉，而不是注释掉。

如果未来有人真的需要用到这些旧代码，他直接去Git仓库历史里就能找到，毕竟版本控制系统就是专门干这个的。

02. 用注释复述代码

在编写注释是，新手常犯的另一类错误是用注释复述代码。就像这样

```python
#调用strip()去掉空格
input_string = input_string.strip()
```

好的注释应该像下面这样：

```python
#如果直接把带空格的输入传递到后端处理，可能会造成后端服务崩溃
# 因此使用strip() 去掉首尾空格
input_string = input_string.strip()
```

指引性注释

简明扼要地概括代码功能，起到“代码导读”的作用。

主要作用是降低代码的认知成本，让我们能够更容易理解代码的意图。


```python
#初始化访问服务的client对象
token = token_service.get_token()
service_client = ServiceClient(token=token)
service_client.ready()
# 调用服务获取数据，然后进行过滤
data = service_client.fetch_full_data()
for item in data:
    if item.value > SOME_VALUE:
        ...
```

03. 弄错接口注释的受众

```python
def resize_image(image, size):
    """将图片缩放到指定尺寸，并返回新的图片。
    该函数将使用Pilot 模块读取文件对象，然后调用.resize() 方法将其缩放到指定尺寸。
    但由于Pilot 模块自身限制，这个函数不能很好地处理过大的文件，当文件大小超过 5MB 时，
    resize() 方法的性能就会因为内存分配问题急剧下降，详见 Pilot 模块的Issue #007。因此，
    对于超过 5MB 的图片文件，请使用resize_big_image() 替代，后者基于Pillow 模块开发，
    很好地解决了内存分配问题，确保性能更好了。
    :param image: 图片文件对象
    :param size: 包含宽高的元组：（width, height）
    :return: 新图片对象
    """
```

我们应该站在函数设计者的角度，着重描述函数的功能、参数说明等。


```python
def resize_image(image, size):
    """将图片缩放到指定尺寸，并返回新的图片。
    注意：当文件超过 5MB 时，请使用resize_big_image()
    :param image: 图片文件对象
    :param size: 包含宽高的元组：（width, height）
    :return: 新图片对象
    """
```

## 1.2 案例故事

```python
def magic_bubble_sort(numbers):
    j = len(numbers) - 1　　
    while j > 0:
        for i in range(j):
            if numbers[i] % 2 == 0 and numbers[i + 1] % 2 == 1:
                numbers[i], numbers[i + 1] = numbers[i + 1], numbers[i]
                continue
        elif (numbers[i + 1] % 2 == numbers[i] % 2) and numbers[i] > numbers[i + 1]:
            numbers[i], numbers[i + 1] = numbers[i + 1], numbers[i]
            continue
    j -= 1
return numbers
```

新代码主要进行了以下改进。

1. 变量名变成了可读的、有意义的名字，比如在旧代码里，“停止位”是无意义的j, 新代码里变成了stop_position.
2. 增加了有意义的临时变量，比如current/next_ 代表前一个/后一个元素、{}_is_even代表元素是否为偶数、should_swap代表是否应该交换元素。
3. 多了一点儿恰到好处的指引性注释，比如说明交换元素顺序的详细条件。

```python
def magic_bubble_sort(numbers: List[int]):
    """有魔力的冒泡排序算法，默认所有的偶数都比奇数大
    :param numbers: 需要排序的列表，函数会直接修改原始列表
    """
    stop_position = len(numbers) - 1
    while stop_position > 0:
        for i in range(stop_position):
            current, next_ = numbers[i], numbers[i + 1] ➊
            current_is_even, next_is_even = current % 2 == 0, next_ % 2 == 0
            should_swap = False
            # 交换位置的两个条件：
            # - 前面是偶数，后面是奇数
        # - 前面和后面同为奇数或者偶数，但是前面比后面大
        if current_is_even and not next_is_even:
            should_swap = True
        elif current_is_even == next_is_even and current > next_:
            should_swap = True
        if should_swap:
            numbers[i], numbers[i + 1] = numbers[i + 1], numbers[i]
    stop_position -= 1
return numbers
```

### 1.3.1 保持变量的一致性

在使用变量时，你需要保证它在两个方面的一致性：名字一致性与类型一致性

名字一致性是指在同一个项目（或者模块、函数）中，对一类事物的称呼不要变来变去。

