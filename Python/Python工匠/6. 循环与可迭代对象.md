# 循环与可迭代对象

for 需要配合一个可迭代对象iterable使用：

```python
#循环打印列表里所有字符串的长度
names = ['foo', 'bar', 'foobar']

for name in names:
    print(len(name))
```

如果把上面的for循环翻译成while, 代码会变长不少：

```python
i = 0
while i < len(names):
    print(len(names[i]))
    i += 1
```

对于一些常见的循环任务，使用for比while要方便得多。

因此在日常编码中，for的出场频率也远比while要高得多。


要把循环代码写的漂亮，有时关键不在循环结构自身，而在于另一个用来配合循环得主角：可迭代对象。

## 6.1 基础知识

### 6.1.1 迭代器与可迭代对象

01. iter() 与 next() 内置函数

调用iter() 会尝试返回一个迭代器对象。

- 列表类型的迭代器对象——list_iterator
- 字符串类型的迭代器对象——str_iterator
- 对不可迭代的类型执行iter()会抛出TypeError异常

迭代器最鲜明的特征是： 不断对它执行next() 函数会返回下一次迭代结果。

当迭代器没有更多值可以返回时，便会抛出StopIteration异常：

```python
>>> next(iter_l)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

当你对迭代器执行iter() 函数，尝试获取迭代器的迭代器对象时，返回的结果一定是迭代器本身：

```python
>>> iter_l
<list_iterator object at 0x101a82d90>
>>> iter(iter_l) is iter_l
True
```

当你使用for循环遍历某个可迭代对象时，其实是先调用了iter()拿到它的迭代器，然后不断地用next()从迭代器中获取值。

```python
names = ['foo', 'bar', 'foobar']
for name in names:
    print(name)
```

02. 自定义迭代器

要自定义一个迭代器类型，关键在于实现下面这两个魔法方法。

- `__iter__` :调用iter() 时触发，迭代器对象总是返回自身。

- `__next__`: 调用next()时触发，通过return来返回结果，没有更多内容就抛出StopIteration异常


```python
class Range7:
    """生成某个范围内可被 7 整除或包含 7 的整数
    :param start: 开始数字
    :param end: 结束数字
    """
    def __init__(self, start, end):
        self.start = start
        self.end = end
        # 使用current 保存当前所处的位置
        self.current = start
    def __iter__(self):
        return self
    def __next__(self):
        while True:
       # 当已经到达边界时，抛出异常终止迭代
       if self.current >= self.end:
           raise StopIteration
       if self.num_is_valid(self.current):
           ret = self.current
           self.current += 1
           return ret
       self.current += 1
    def num_is_valid(self, num):
        """判断数字是否满足要求"""
        if num == 0:
            return False
        return num % 7 == 0 or '7' in str(num)
```

我们可以通过for循环来验证这个迭代器的执行效果

```python
>>> r = Range7(0, 20)
>>> for num in r:
...     print(num)
...
7
14
17
```

不过，虽然上面的代码满足需求，但在进一步使用时，我们会发现现在的Range7对象有一个问题，那就是每个新Range7对象只能被完整遍历一次，假如做二次遍历，就会拿不到任何结果

他其实是所有迭代器的“通病”。

```python
>>> r = Range7(0, 20)
>>> tuple(r)
(7, 14, 17)
>>> tuple(r) ➊
```