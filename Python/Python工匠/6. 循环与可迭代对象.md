# 循环与可迭代对象

for 需要配合一个可迭代对象iterable使用：

```python
#循环打印列表里所有字符串的长度
names = ['foo', 'bar', 'foobar']

for name in names:
    print(len(name))
```

如果把上面的for循环翻译成while, 代码会变长不少：

```python
i = 0
while i < len(names):
    print(len(names[i]))
    i += 1
```

对于一些常见的循环任务，使用for比while要方便得多。

因此在日常编码中，for的出场频率也远比while要高得多。


要把循环代码写的漂亮，有时关键不在循环结构自身，而在于另一个用来配合循环得主角：可迭代对象。

## 6.1 基础知识

### 6.1.1 迭代器与可迭代对象

01. iter() 与 next() 内置函数

调用iter() 会尝试返回一个迭代器对象。

- 列表类型的迭代器对象——list_iterator
- 字符串类型的迭代器对象——str_iterator
- 对不可迭代的类型执行iter()会抛出TypeError异常

迭代器最鲜明的特征是： 不断对它执行next() 函数会返回下一次迭代结果。

当迭代器没有更多值可以返回时，便会抛出StopIteration异常：

```python
>>> next(iter_l)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

当你对迭代器执行iter() 函数，尝试获取迭代器的迭代器对象时，返回的结果一定是迭代器本身：

```python
>>> iter_l
<list_iterator object at 0x101a82d90>
>>> iter(iter_l) is iter_l
True
```

当你使用for循环遍历某个可迭代对象时，其实是先调用了iter()拿到它的迭代器，然后不断地用next()从迭代器中获取值。

```python
names = ['foo', 'bar', 'foobar']
for name in names:
    print(name)
```

02. 自定义迭代器

要自定义一个迭代器类型，关键在于实现下面这两个魔法方法。

- `__iter__` :调用iter() 时触发，迭代器对象总是返回自身。

- `__next__`: 调用next()时触发，通过return来返回结果，没有更多内容就抛出StopIteration异常


```python
class Range7:
    """生成某个范围内可被 7 整除或包含 7 的整数
    :param start: 开始数字
    :param end: 结束数字
    """
    def __init__(self, start, end):
        self.start = start
        self.end = end
        # 使用current 保存当前所处的位置
        self.current = start
    def __iter__(self):
        return self
    def __next__(self):
        while True:
       # 当已经到达边界时，抛出异常终止迭代
       if self.current >= self.end:
           raise StopIteration
       if self.num_is_valid(self.current):
           ret = self.current
           self.current += 1
           return ret
       self.current += 1
    def num_is_valid(self, num):
        """判断数字是否满足要求"""
        if num == 0:
            return False
        return num % 7 == 0 or '7' in str(num)
```

我们可以通过for循环来验证这个迭代器的执行效果

```python
>>> r = Range7(0, 20)
>>> for num in r:
...     print(num)
...
7
14
17
```

不过，虽然上面的代码满足需求，但在进一步使用时，我们会发现现在的Range7对象有一个问题，那就是每个新Range7对象只能被完整遍历一次，假如做二次遍历，就会拿不到任何结果

他其实是所有迭代器的“通病”。

```python
>>> r = Range7(0, 20)
>>> tuple(r)
(7, 14, 17)
>>> tuple(r) ➊
```

03. 区别迭代器与可迭代对象

迭代器是可迭代对象的一种。

它最常出现的场景是在迭代其他对象时，作为一种介质或工具对象存在——就像调用`iter([])`时返回的是`list_iterator`。

每个迭代器都对应一次完整的迭代过程，因此它自身必须保存与当前迭代相关的状态——迭代位置（就像Range7里面的current属性）。

一个合法的迭代器，必须同时实现`__iter__`和`__next__`两个魔法方法。

相比之下，可迭代对象定义则宽泛许多。判断一个对象obj是否可迭代的唯一标准，就是调用iter(obj)，然后看结果是不是一个迭代器。

因此，可迭代对象只需实现`__iter__`方法，不一定得实现`__next__`方法。

所以，如果想让Range7对象在每次迭代时都返回完整结果，必须把现在代码拆分成两部分：可迭代类型Range7和迭代器类型Range7Iterator.

```python
class Range7:
    """生成某个范围内可被 7 整除或包含 7 的数字"""
    def __init__(self, start, end):
        self.start = start
        self.end = end
    def __iter__(self):
        # 返回一个新的迭代器对象
        return Range7Iterator(self)
　
　
class Range7Iterator:
    def __init__(self, range_obj):
        self.range_obj = range_obj
        self.current = range_obj.start
    def __iter__(self):
        return self
    def __next__(self):
        while True:
            if self.current >= self.range_obj.end:
                raise StopIteration
            if self.num_is_valid(self.current):
                ret = self.current
                self.current += 1
                return ret
            self.current += 1
    def num_is_valid(self, num):
        if num == 0:
            return False
        return num % 7 == 0 or '7' in str(num)
```

迭代器与可迭代对象的区别：

- 可迭代对象不一定时迭代器，但迭代器一定是可迭代对象；
- 对可迭代对象使用iter()会返回迭代器，迭代器则会返回其自身；
- 每个迭代器的被迭代过程时一次性的，可迭代对象则不一定；
- 可迭代对象只需要实现`_iter_`方法，而迭代器要额外实现`__next__`方法。

04. 生成器是迭代器

生成器是一种简化的迭代器实现，使用它可以大大降低实现传统迭代器的编码成本。

因此，只要写上几个yield就行。

如果利用生成器，上面的Range7Iterator可以改写成一个只有5行代码的函数

```python
def range_7_gen(start, end):
    """生成器版本的Range7Iterator"""
    num = start
    while num < end:
        if num != 0 and (num % 7 == 0 or '7' in str(num)):
            yield num
        num += 1
```

我们可以用`iter()`和`next()`函数来验证“生成器就是迭代器”这个事实：

```python
>>> nums = range_7_gen(0, 20)
# 使用iter() 函数测试
>>> iter(nums)
<generator object range_7_gen at 0x10404b2e0>
>>> iter(nums) is nums
True
# 使用next() 不断获取下一个值
>>> next(nums)
7
>>> next(nums)
14
```

生成器利用其简单的语法，大大降低了迭代器的使用门槛，是优化循环代码时最得力的帮手。

### 6.1.2 修饰可迭代对象优化循环

`enumerate()`是Python的一个内置函数，它接收一个可迭代对象作为参数，返回一个不断生成（当前下标，当前元素）的新可迭代对象。

虽然`enumerate()`函数很简单，但它其实代表了一种循环代码优化的思路：通过修饰可迭代对象来优化循环。

**使用生成器函数修饰可迭代对象**

什么是“修饰可迭代对象”？

```python
def sum_even_only(numbers):
    """对numbers 里面所有的偶数求和"""
    result = 0
    for num in numbers:
        if num % 2 == 0:
            result += num
    return result
```

借鉴`enumerate()`函数的思路，其实可以把这个函数提炼成一个生成器函数，从而简化循环内部代码。

```python
def even_only(numbers):
    for num in numbers:
        if num % 2 == 0:
            yield num
```

```python
def sum_even_only_v2(numbers):
    """对numbers 里面所有的偶数求和"""
    result = 0
    for num in even_only(numbers):
        result += num
    return result
```

"修饰可迭代对象"是指用生成器（或普通迭代器）在循环外部包装原本的循环主体，完成一些原本必须在循环内部执行的工作——比如过滤特定成员，提供额外结果等等，以此简化循环代码。

除了自定义修饰函数外，你还可以直接使用标准库模块itertools里的许多现成工具。

### 6.1.3 使用itertools模块优化循环

itertools 是一个和迭代器有关的标准库模块，其中包含许多用来处理可迭代对象的工具函数。

01. 使用product()扁平化多层嵌套循环

```python
def find_twelve(num_list1, num_list2, num_list3):
    """从3 个数字列表中，寻找是否存在和为 12 的3 个数"""
    for num1 in num_list1:
        for num2 in num_list2:
            for num3 in num_list3:
                if num1 + num2 + num3 == 12:
                    return num1, num2, num3
```

product() 接收多个可迭代对象作为参数，然后根据它们的笛卡尔积不断生成结果：

```python
>>> from itertools import product
>>> list(product([1, 2], [3, 4]))
[(1, 3), (1, 4), (2, 3), (2, 4)]
```

```python
from itertools import product
　
　
def find_twelve_v2(num_list1, num_list2, num_list3):
    for num1, num2, num3 in product(num_list1, num_list2, num_list3):
        if num1 + num2 + num3 == 12:
            return num1, num2, num3
```

02. 使用islice()实现循环内隔行处理

03. 使用takewhile() 替代break语句

### 6.1.4 循环语句的else关键字

建议少用


## 6.2 案例故事

01. 读取文件的标准做法

首先用`with open(file_name)`上下文管理器语法获得一个文件对象，然后用for循环迭代它，**逐行**获取文件里的内容。

- with 上下文管理器会自动关闭文件描述符；
- 在迭代文件对象时，内容是一行一行返回的，不会占用太多内存。

假如没有任何换行符，那么上面第二个好处就不再成立。

02. 使用while循环加read()方法分块读取

除了直接遍历文件对象来逐行读取文件内容外，我们还可以调用更底层的`file.read()`方法。

与直接用循环迭代文件对象不同，每次调用`file.read(chunk_size)`,会马上读取从当前游标位置往后chunk_size大小的文件内容，不必等待任何换行符出现。

```python
def count_digits_v2(fname):
    """计算文件里包含多少个数字字符，每次读取 8 KB"""
    count = 0
    block_size = 1024 * 8
    with open(fname) as file:
        while True:
            chunk = file.read(block_size)
            # 当文件没有更多内容时，read 调用将会返回空字符串 ''
            if not chunk:
                break
            for s in chunk:
                if s.isdigit():
                    count += 1
    return count
```

03. iter() 的另一个用法

`iter()`是一个用来获取迭代器的内置函数，它其实还有另一个鲜为人知的用法。

当我们以iter(callable, sentinel)的方式调用iter()函数时，会拿到一个特殊的迭代器对象。用循环遍历这个迭代器，会不断返回调用callable()的结果，假如结果等于sentinel, 迭代过程中止。

```python
from functools import partial
def count_digits_v3(fname):
    count = 0
    block_size = 1024 * 8
    with open(fname) as fp:
        # 使用functools.partial 构造一个新的无须参数的函数
        _read = partial(fp.read, block_size) ➊
        # 利用iter() 构造一个不断调用_read 的迭代器
        for chunk in iter(_read, ''):
            for s in chunk:
                if s.isdigit():
                    count += 1
    return count
```

04. 按职责拆解循环体代码

需要统计文件里面所有偶数字符出现的次数。

读取数字内容的生成器函数

```python
def read_file_digits(fp, block_size=1024 * 8):
    """生成器函数：分块读取文件内容，返回其中的数字字符"""
    _read = partial(fp.read, block_size)
    for chunk in iter(_read, ''):
        for s in chunk:
            if s.isdigit():
                yield s
```

复用读取函数后的统计函数

```python
def count_digits_v4(fname):
    count = 0
    with open(fname) as file:
        for _ in read_file_digits(file):
            count += 1
    return count
```


复用后读取函数后的统计偶数函数

```python
from collections import defaultdict
def count_even_groups(fname):
    """分别统计文件里每个偶数字符出现的次数"""
    counter = defaultdict(int)
    with open(fname) as file:
        for num in read_file_digits(file):
            if int(num) % 2 == 0:
                counter[int(num)] += 1
    return counter
```

## 6.3 编程建议

### 6.3.1 中断嵌套循环的正确方式

如果想快速从嵌套循环里跳出，那就是把循环代码拆分为一个新函数，然后直接使用return.

### 6.3.2 巧用next() 函数

### 6.3.3 当心已被耗尽的迭代器

生成器或者说它的父类迭代器最大的陷阱之一是：会被耗尽