# 循环与可迭代对象

for 需要配合一个可迭代对象iterable使用：

```python
#循环打印列表里所有字符串的长度
names = ['foo', 'bar', 'foobar']

for name in names:
    print(len(name))
```

如果把上面的for循环翻译成while, 代码会变长不少：

```python
i = 0
while i < len(names):
    print(len(names[i]))
    i += 1
```

对于一些常见的循环任务，使用for比while要方便得多。

因此在日常编码中，for的出场频率也远比while要高得多。


要把循环代码写的漂亮，有时关键不在循环结构自身，而在于另一个用来配合循环得主角：可迭代对象。

## 6.1 基础知识

### 6.1.1 迭代器与可迭代对象

01. iter() 与 next() 内置函数

调用iter() 会尝试返回一个迭代器对象。

- 列表类型的迭代器对象——list_iterator
- 字符串类型的迭代器对象——str_iterator
- 对不可迭代的类型执行iter()会抛出TypeError异常

迭代器最鲜明的特征是： 不断对它执行next() 函数会返回下一次迭代结果。

当迭代器没有更多值可以返回时，便会抛出StopIteration异常：

```python
>>> next(iter_l)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

当你对迭代器执行iter() 函数，尝试获取迭代器的迭代器对象时，返回的结果一定是迭代器本身：

```python
>>> iter_l
<list_iterator object at 0x101a82d90>
>>> iter(iter_l) is iter_l
True
```

当你使用for循环遍历某个可迭代对象时，其实是先调用了iter()拿到它的迭代器，然后不断地用next()从迭代器中获取值。

```python
names = ['foo', 'bar', 'foobar']
for name in names:
    print(name)
```

02. 自定义迭代器

要自定义一个迭代器类型，关键在于实现下面这两个魔法方法。

- `__iter__` :调用iter() 时触发，迭代器对象总是返回自身。

- `__next__`: 调用next()时触发，通过return来返回结果，没有更多内容就抛出StopIteration异常