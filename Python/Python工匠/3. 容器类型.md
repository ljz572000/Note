# 3. 容器类型

在Python中，最常见的内置容器类型有四种：列表、元组、字典、集合。

列表（list）是一种经典的容器类型，通常用来存放多个同类对象

元组（tuple）和列表非常类似，但跟列表不同，他不能被修改。

字典（dict）类型存放的是一个个键值对（key:value). 它功能强大，应用广泛。就连Python内部也大量使用，比如每个类实列的所有属性，就都存放在一个名为dict的字典里：

集合（set）也是一种常用的容器类型。它最大的特点是成员不能重复，所以经常用来去重。


## 3.1 基础知识

### 列表常用操作

使用`[]`符号来创建一个列表字面量：

```python
>>> numbers = [1, 2, 3, 4]
```

内置函数list(iterable) 则可以把任何一个可迭代对象转换为列表，比如字符串：

```python
>>> list('foo')
['f', 'o', 'o']
```

```python
#通过索引获取内容，如果索引越界，会抛出 IndexError异常
>>> numbers[2]
3

# 使用切片获取一段内容
>>> numbers[1:]
[2, 3, 4]

#  删除列表中的一段内容
>>> del numbers[1:]
>>> numbers
[1]
```

01. 在遍历列表时获取下标

```python
>>> names = ['foo', 'bar']
>>> for index, s in enumerate(names):
...     print(index, s)
...
0 foo
1 bar
```

enumerate() 接收一个可选的start参数，用于指定循环下标的初始值（默认为0）

```python
>>> for index, s in enumerate(names, start=10):
...     print(index, s)
...
10 foo
11 bar
```

enumerate() 适用于任何“可迭代对象”，因此它不光可用于列表，还可以用于元组，字典、字符串等其他对象。

02. 列表推导式

列表推导式。使用列表推导式，上面函数里的6行代码可以压缩成一行：

```python
#用一个表达式完成4件事情
#
# 1. 遍历旧列表：for n in numbers
# 2. 对成员进行条件过滤：if n % 2 == 0
# 3. 修改成员： n * 100
# 4. 组装新的结果列表
#
results = [n * 100 for n in numbers if n % 2 == 0]
```

相对于传统风格的旧代码，列表推导式把几类操作压缩在了一起


### 3.1.2 理解列表的可变性

- 可变（mutable）: 列表、字典、集合
- 不可变（immutable）：整数、浮点数、字符串、字节串、元组

示例一：为字符串追加内容

```python
def add_str(in_func_obj):
    print(f'In add [before]: in_func_obj="{in_func_obj}"')
    in_func_obj += ' suffix'
    print(f'In add [after]: in_func_obj="{in_func_obj}"')


orig_obj = 'foo'
print(f'Outside [before]: orig_obj="{orig_obj}"')
add_str(orig_obj)
print(f'Outside [after]: orig_obj="{orig_obj}"')
```

函数外的orig_obj 变量所指向的值没有受到任何影响。



```
Outside [before]: orig_obj="foo"
In add [before]: in_func_obj="foo"
In add [after]: in_func_obj="foo suffix"

# 重要：这里的orig_obj 变量还是原来的值
Outside [after]: orig_obj="foo"
```

示例二：为列表追加内容

在这个例子中，我们保留一模一样的代码逻辑

```python
def add_list(in_func_obj):
    print(f'In add [before]: in_func_obj="{in_func_obj}"')
    in_func_obj += ['baz']
    print(f'In add [after]: in_func_obj="{in_func_obj}"')


orig_obj = ['foo', 'bar']
print(f'Outside [before]: orig_obj="{orig_obj}"')
add_list(orig_obj)
print(f'Outside [after]: orig_obj="{orig_obj}"')
```

结果大不一样

```python
Outside [before]: orig_obj="['foo', 'bar']"
In add [before]: in_func_obj="['foo', 'bar']"
In add [after]: in_func_obj="['foo', 'bar', 'baz']"

# 注意：函数外的orig_obj 变量的值已经被修改了！
Outside [after]: orig_obj="['foo', 'bar', 'baz']"
```

示例解释

1. 值传递：调用函数时，传递时变量所指向对象的拷贝，因此对函数变量的任何修改，都不会影响原始变量。
2. 引用传递：调用函数时，传过去的时变量自身的引用（内存地址），因此，修改函数内的变量会直接影响到原始变量。

Python在进行函数调用传参时，采用的既不是值传递，也不是引用传递，而是传递了“**变量所指对象的引用**”（pass-by-object-reference）.

换个角度说，当你调用func(orig_obj)后，Python只是新建了一个函数内部变量in_func_obj, 然后让它和外部变量orig_obj指向同一个对象，相当于做了一次变量赋值：

```python
def func(in_func_obj): ...

orig_obj = ...
func(orig_obj)
```

### 3.1.3 常用元组操作

### 3.1.4 具名元组



```python
from collections import namedtuple

Rectangle = namedtuple('Rectangle', 'width,height') ➊
```


```python
>>> rect = Rectangle(100, 20) ➊
>>> rect = Rectangle(width=100, height=20) ➋
>>> print(rect[0]) ➌
100
>>> print(rect.width) ➍
100
>>> rect.width += 1 ➎
...
AttributeError: can't set attribute
```

### 3.1.5 字典常用操作

01. 遍历字典

```python
#遍历获取字典所有的key
>>> for key in movie:
...     print(key, movie[key])
# 一次获取字典的所有 key: value 键值对
>>> for key, value in movie.items():
...     print(key, value)
```


02. 访问不存在的字典键

比较常见的处理方式有两种：

1. 读取内容前先做一次条件判断，只有判断通过的情况下才继续执行其他操作；

```python
>>> if 'rating' in movie:
...     rating = movie['rating']
... else:
...     rating = 0
...
```

2. 直接操作，但是捕获KeyError异常.

比较推荐第二种写法，因为看起来更简洁，执行效率也更高。


```python
>>> try:
...     rating = movie['rating']
... except KeyError:
...     rating = 0
...
```

不过，如果只是“提供默认值的读取操作”，其实可以直接使用.get

当访问的键不存在时，方法会返回default作为默认值：

```python
>>> movie.get('rating', 0) ➊
0
```

03. 使用setdefault取值并修改

我们需要修改字典中某个可能不存在的键

`d.setdefault(key, default=None)`

04. 使用pop方法删除不存在的键

如果我们想删除字典里的某个键，一般会使用del d[key]语句；

但如果要删除的键不存在，该操作就会抛出keyError异常。

因此，要想安全地删除某个键，需要加上一段异常捕获逻辑：

```python
try:
    del d[key]
except KeyError:
    # 忽略 key 不存在的情况
    pass
```

但假设你只是单纯地想去掉某个键，并不关心它存在与否、删除有没有成功，那么使用`dict.pop(key, default)`方法就够了。

```python
d.pop(key, None)
```

05. 字典推导式

```python
>>> d1 = {'foo': 3, 'bar': 4}
>>> {key: value * 10 for key, value in d1.items() if key == 'foo'}
{'foo': 30}
```


### 3.1.6 认识字典的有序性与无序性

Python的字典是无序的。

Python里的字典在底层使用了哈希表（hash table) 数据结构。

当你往字典里存放一对key: value 是，Python会先通过哈希算法计算出key的哈希值——一个整型数字；
然后根据这个哈希值，决定数据在表里的具体位置。

但Python语言在不断进化。 Python 3.6 为字典类型引入了一个改进：优化了底层实现，同样的字典相比3.5版本可节约多达25%的内存。而这个改进：字典变得有序了。

OrderedDict, 可以在Python 3.7 以前的版本里保证字典有序。


### 3.1.7 集合常用操作

集合是一种无序的可变容器类型，它最大的特点就是成员不能重复。

集合也有自己的推导式

```python
>>> nums = [1, 2, 2, 4, 1]
>>> {n for n in nums if n < 3}
{1, 2}
```

01. 不可变的集合frozenset

集合是一种可变的类型，使用.add()方法可以向集合追加新成员：

```python
>>> new_set = set(['foo', 'foo', 'bar'])
>>> new_set.add('apple')
>>> new_set
{'apple', 'bar', 'foo'}
```

使用内置类型frozenset, 它和普通set非常像，只是少了所有的修改类方法：

```python
>>> f_set = frozenset(['foo', 'bar'])
>>> f_set.add('apple')
# 报错：没有 add/remove 那些修改集合的方法
AttributeError: 'frozenset' object has no attribute 'add'
```

02. 集合运算

可以对其进行真正的集合运算，比如求交集、并集、差集等等。

所有操作都可以用两种方式来进行：方法和运算符。

```python
>>> fruits_1 = {'apple', 'orange', 'pineapple'}
>>> fruits_2 = {'tomato', 'orange', 'grapes', 'mango'}
```

交集

```python
#使用& 运算符
>>> fruits_1 & fruits_2
{'orange'}
# 使用intersection 方法完成同样的功能
>>> fruits_1.intersection(fruits_2)
...
```

合集

```python
#使用| 运算符
>>> fruits_1 | fruits_2
{'mango', 'orange', 'grapes', 'pineapple', 'apple', 'tomato'}
# 使用union 方法完成同样的功能
>>> fruits_1.union(fruits_2)
...
```

差集

```java
#使用- 运算符
>>> fruits_1 - fruits_2
{'apple', 'pineapple'}
# 使用difference 方法完成同样的功能
>>> fruits_1.difference(fruits_2)
...
```

03. 集合只能存放可哈希对象

```python
>>> invalid_set = {'foo', [1, 2, 3]}
...
TypeError: unhashable type: 'list'
```


### 3.1.8 了解对象的可哈希性

首先，那些不可变的内置类型都是可哈希的：

```python
>>> hash('string')
-3407286361374970639
>>> hash(100)
# 有趣的事情，整型的hash 值就是它自身的值
100
>>> hash((1, 2, 3))
529344067295497451
```

可变的内置类型都无法正常计算哈希值：

```python
>>> hash({'key': 'value'})
TypeError: unhashable type: 'dict'
>>> hash([1, 2, 3])
TypeError: unhashable type: 'list'
```

### 3.1.9 深拷贝与浅拷贝

```python
>>> nums = [1, 2, 3, 4]
>>> nums_copy = nums
>>> nums[2] = 30
>>> nums_copy ➊
[1, 2, 30, 4]
```

01. 浅拷贝

要进行浅拷贝，最通用的办法是使用copy模块下的copy()方法：

```python
>>> import copy
>>> nums_copy = copy.copy(nums)
>>> nums[2] = 30
# 修改不再相互影响
>>> nums, nums_copy
([1, 2, 30, 4], [1, 2, 3, 4])
```

02. 深拷贝

大部分情况下，上面的浅拷贝操作足以满足我们对可变类型的复制需求。

但对于一些层层嵌套的复杂数据来说，浅拷贝仍然无法解决嵌套对象被修改的问题。

要解决这个问题，可以用`copy.deepcopy()`函数来进行深拷贝操作：

```python
>>> items_deep = copy.deepcopy(items)
```


## 3.2 案例故事

01. 使用defaultdict类型

一种特殊的字典类型。它在被初始化时，接收一个可调用对象default_factory作为参数。

之后每次进行d[key]操作时，如果访问的key不存在，defaultdict对象会自动调用default——factory()并将结果作为值保存在对应key里。

```python
>>> from collections import defaultdict
>>> int_dict = defaultdict(int)
```

02. 使用MutableMapping创建自定义字典类型

自定义字典和普通字典很像，但它可以非字典的默认行为加上一些变化。



在Python 中定义一个字典类型，可通过继承MutableMapping抽象类来实现。


```python
from collections.abc import MutableMapping
　
　
class PerfLevelDict(MutableMapping):
    """存储响应时间性能等级的字典"""
    def __init__(self):
        self.data = defaultdict(int)
    def __getitem__(self, key):
        """当某个级别不存在时，默认返回 0"""
        return self.data[self.compute_level(key)]
    def __setitem__(self, key, value):
        """将 key 转换为对应的性能等级，然后设置值"""
        self.data[self.compute_level(key)] = value
    def __delitem__(self, key):
        del self.data[key]
    def __iter__(self):
        return iter(self.data)
    def __len__(self):
        return len(self.data)
    @staticmethod
    def compute_level(time_cost_str):
        """根据响应时间计算性能等级"""
        # 假如已经是性能等级，不做转换直接返回
        if time_cost_str in list(PagePerfLevel):
            return time_cost_str
        time_cost = int(time_cost_str)
        if time_cost < 100:
            return PagePerfLevel.LT_100
        elif time_cost < 300:
            return PagePerfLevel.LT_300
        elif time_cost < 1000:
            return PagePerfLevel.LT_1000
        return PagePerfLevel.GT_1000
```

但光继承还不够，要让这个类变得像字典一样，还需要重写包括`_getitem_`、`_setitem_`在内的6个魔法方法。

PerfLevelDict 的`_getitem_` / `_setitem_` 方法和普通字典的最大不同，在于操作前调用了`compute_level()`, 将字典键转成了性能等级。

03. 代码重构

有了自定义字典PerfLevelDict的帮助，analyze_v2() 函数的整个逻辑变得非常清晰，非常容易理解。

```python
from enum import Enum
from collections import defaultdict
from collections.abc import MutableMapping
　
　
class PagePerfLevel(str, Enum):
    LT_100 = 'Less than 100 ms'
    LT_300 = 'Between 100 and 300 ms'
    LT_1000 = 'Between 300 ms and 1 s'
    GT_1000 = 'Greater than 1 s'
　
　
class PerfLevelDict(MutableMapping):
    """存储响应时间性能等级的字典"""
    def __init__(self):
        self.data = defaultdict(int)
    def __getitem__(self, key):
        """当某个性能等级不存在时，默认返回 0"""
        return self.data[self.compute_level(key)]
    def __setitem__(self, key, value):
        """将 key 转换为对应的性能等级，然后设置值"""
        self.data[self.compute_level(key)] = value
    def __delitem__(self, key):
        del self.data[key]
    def __iter__(self):
        return iter(self.data)
    def __len__(self):
        return len(self.data)
    def items(self):
        """按照顺序返回性能等级数据"""
        return sorted(
            self.data.items(),
            key=lambda pair: list(PagePerfLevel).index(pair[0]),
        )
    def total_requests(self):
        """返回总请求数"""
        return sum(self.values())
    @staticmethod
    def compute_level(time_cost_str):
        """根据响应时间计算性能等级"""
        if time_cost_str in list(PagePerfLevel):
            return time_cost_str
        time_cost = int(time_cost_str)
        if time_cost < 100:
            return PagePerfLevel.LT_100
        elif time_cost < 300:
            return PagePerfLevel.LT_300
        elif time_cost < 1000:
            return PagePerfLevel.LT_1000
        return PagePerfLevel.GT_1000
def analyze_v2():
    path_groups = defaultdict(PerfLevelDict)
    with open("logs.txt", "r") as fp:
        for line in fp:
            path, time_cost = line.strip().split()
            path_groups[path][time_cost] += 1
    for path, result in path_groups.items():
        print(f'== Path: {path}')
        print(f'   Total requests: {result.total_requests()}')
        print(f'   Performance:')
        for level_name, count in result.items():
            print(f'     - {level_name}: {count}')
　
　
if __name__== '__main__':
    analyze_v2()
```


**为何不直接继承dict?**

如果真的继承dict来创建自定义字典类型，你会碰到很多问题。

拿一个最常见的场景来说，假如你继承了dict,通过`_setitem_`方法重写了它的键赋值操作。此时，虽然，常规的d[key] = value行为会被重写；但假如调用方使用`d.update(...)`来更新字典内容，就根本不会触发重写后的键赋值逻辑。

```python
class UpperDict(dict):
    """总是把 key 转为大写"""
    def __setitem__(self, key, value):
        super().__setitem__(key.upper(), value)
```

`.update(...)` 方法并不会触发任何自定义逻辑

```python
>>> d = UpperDict()
>>> d['foo'] = 1  ➊
>>> d
{'FOO': 1}
>>> d.update({'bar': 2})  ➋
>>> d
{'FOO': 1, 'bar': 2}
```


## 3.3 编程建议

### 3.3.1 用按需返回替代容器

Python 3， 调用range(100000)

1. 返回一个类型为range的惰性计算对象。
2. 只有在迭代range对象时，它才会不断生成新的数字

它其实代表了一种重要的编程思维

**按需生成，而不是一次性返回。**

Python里的生成器对象非常适合用来实现“按需生成”。

01. 生成器简介

定义一个生成器，需要用到生成器函数与yield关键字。

```python
def generate_even(max_number):
    """一个简单生成器，返回 0 到 max_number 之间的所有偶数"""
    for i in range(0, max_number):
        if i % 2 == 0:
            yield i
for i in generate_even(10):
    print(i)
```

> yield 和 return 最大不同之处在于，return的返回是一次性的，使用它会直接中断整个函数执行，而yield可以逐步给调用方生成结果：
>

```python
>>> i = generate_even(10)
>>> next(i)
0
>>> next(i) ➊
2
```

02. 用生成器替代列表

```python
def batch_process(items):
    """
    批量处理多个 items 对象
    """
    # 初始化空结果列表
    results = []
    for item in items:
        # 处理 item，可能需要耗费大量时间……
        # processed_item = ...
        results.append(processed_item)
    # 将拼装后的结果列表返回
    return results
```
问题一：

如果需要处理的对象items过大，batch_process() 函数就会像Python 2里的range() 函数一样，每次执行都特别满，存放结果的对象results也会占用大量内存。

问题二：

如果函数调用方想在某个processed_item对象满足特定条件时终端，不再继续处理后面的对象，现在的batch_process() 函数也做不到——它每次都得一次性处理完所有items才会返回。


简单来说，就是用yield item替代append语句。

```python
def batch_process(items):
    for item in items:
        # 处理 item，可能需要耗费大量时间……
        # processed_item = ...
        yield processed_item
```

生成器函数不仅看上去更短，而且很好地解决了前面的两个问题。

当输入参数items很大时，batch_process() 不再需要一次性拼装返回一个巨大的结果列表，内存占用更小，执行起来也更快。

如果调用方需要在某些条件下中断处理，也完全可以做到：

```python
#调用方
for processed_item in batch_process(items):
    # 如果某个已处理对象过期了，就中断当前的所有处理
    if processed_item.has_expired():
        break
```

### 3.3.2 了解容器的底层实现

了解各容器的底层实现仍然很重要。

因为只有了解底层实现，你下可以在编程时避开一些常见的性能陷阱，写出运行更快的代码。

01. 避开列表的性能陷阱

```python
def list_append():
    """不断往尾部追加"""
    l = []
    for i in range(5000):
        l.append(i)


def list_insert():
    """不断往头部插入"""
    l = []
    for i in range(5000):
        l.insert(0, i)


import timeit

# 默认执行 1 万次
append_spent = timeit.timeit(
    setup='from __main__ import list_append',
    stmt='list_append()',
    number=10000,
)

print("list_append:", append_spent)

insert_spent = timeit.timeit(
    setup='from __main__ import list_insert',
    stmt='list_insert()',
    number=10000,
)
print("list_insert", insert_spent)
```

同样是构建一个长度为5000的列表，不断往头部插入的insert方式的耗时是从尾部追加的append方式的16倍还多。为什么会这样呢？



```
list_append: 3.0792130999998335
list_insert 44.646921999999904
```

Python在实现列表时，底层使用了数组（array）数据结构。这种结构最大的一个特点是，当你在数组中间插入新成员时，该成员之后的其他成为都需要移动位置，该操作的平均时间复杂度时O(n).

因此，在列表的头部插入成员，比在尾部追加要慢得多（后者时间复杂度为O(1).

如果你经常需要往列表头部插入数据，请考虑使用`collections.deque`类型来替代列表。

因为deque底层使用了双端队列，无论在头部还是尾部追加成员，时间复杂度都是O(1).

```python
from collections import deque

def deque_append():
    """不断往尾部追加"""
    l = deque()
    for i in range(5000):
        l.append(i)

def deque_appendleft():
    """不断往头部插入"""
    l = deque()
    for i in range(5000):
        l.appendleft(i)

# timeit 性能测试代码已省略

import timeit

# 默认执行 1 万次
append_spent = timeit.timeit(
    setup='from __main__ import deque_append',
    stmt='deque_append()',
    number=10000,
)

print("list_append:", append_spent)

insert_spent = timeit.timeit(
    setup='from __main__ import deque_appendleft',
    stmt='deque_appendleft()',
    number=10000,
)
print("deque_appendleft", insert_spent)
```

02. 使用集合判断成员是否存在


```python
>>> nums = list(range(10))
>>> nums
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# 判断成员是否存在
>>> 3 in nums
True
```


因为列表底层使用了数组结构，所以要判断某个存在，唯一办法是从前往后遍历，执行该操作的时间复杂度是O(n).

要判断某个容器是否包含特定成员，用集合比用列表更合适。

在集合里搜索，就像通过字典查字。我们先按照字的拼音从索引找到它所在的页码，然后直接翻到那一页。完成这种操作需要的时间复杂度是O(1).

在集合里搜索之所以这么快，是因为其底层使用了哈希表数据结构。要判断集合中是否存在某个对象obj, Python 只需先用hash(obj)算出它的哈希值，然后直接去哈希表对应位置检查obj是否存在集合，根本不需要关心哈希表的其他部分，一步到位。


```python
#注意：这里的示例列表很短，所以转不转集合对性能的影响可能微乎其微
# 在实际编码时，列表越长、执行的判断次数越多，转成集合的收益就越高
VALID_NAMES = ["piglei", "raymond", "bojack", "caroline"]
# 转换为集合类型专门用于成员判断
VALID_NAMES_SET = set(VALID_NAMES)
　
　
def validate_name(name):
    if name not in VALID_NAMES_SET:
        raise ValueError(f"{name} is not a valid name!")
```

除了集合，对字典进行key in ... 查询同样非常快，因为二者都是基于哈希表结构实现的。

### 3.3.3 掌握如何快速合并字典

要实现合并功能，需要用到双星号**运算符来做解包操作。

在字典中使用**dict_obj 表达式，可以动太解包dict_obj 字典的所有内容，并与当前字典合并。

```python
>>> d1 = {'name': 'apple'}
# 把 d1 解包，与外部字典合并
>>> {'foo': 'bar', **d1}
{'foo': 'bar', 'name': 'apple'}
```

```python
>>> d1 = {'name': 'apple'}
>>> d2 = {'price': 10}

# d1、d2 原始值不会受影响
>>> {**d1, **d2}
{'name': 'apple', 'price': 10}
```

除了使用`**`解包字典，你还可以使用单星号`*`运算符来解包任何可迭代对象

```
>>> [1, 2, *range（3）]
[1, 2, 0, 1, 2]

>>> l1 = [1, 2]
>>> l2 = [3, 4]
# 合并两个列表
>>> [*l1, *l2]
[1, 2, 3, 4]
```

合理利用`*`和`**`运算符，可以帮助我们高效构建列表与字典对象

字典的 `|` 运算符

```
>>> d1 = {'name': 'apple'}
>>> d2 = {'name': 'orange', 'price': 10}
>>> d1 | d2
{'name': 'orange', 'price': 10}
>>> d2 | d1  ➊
{'name': 'apple', 'price': 10}
```

### 3.3.4 使用有序字典去重

集合里的成员不会重复，因此它经常用来去重。

但是使用集合去重有一个很大的缺点：得到的结果丢失集合内成员原有的顺序：

```python
>>> nums = [10, 2, 3, 21, 10, 3]
# 去重但是丢失了顺序
>>> set(nums)
{3, 10, 2, 21}
```


这种无序性是由集合所使用的哈希表结构所决定的，无法避免。

可以使用OrderedDict来完成这件事。

1. 它的键是有序的；
2. 它的键绝不会重复。

### 3.3.5 别在遍历列表时同步修改

```python
def remove_even(numbers):
    """去掉列表里所有的偶数"""
    for number in numbers:
        if number % 2 == 0:
            # 有问题的代码
            numbers.remove(number)


numbers = [1, 2, 7, 4, 8, 11]
remove_even(numbers)
print(numbers)
```


```
[1, 7, 8, 11]
```

是因为：在遍历过程中，循环所使用的索引值不断增加，而被遍历对象numbers里的成员又同时在被删除，长度不断缩短——这最终导致列表里的一些成员其实根本就没被遍历到。

因此，要修改列表，请不要在遍历时直接修改。只需选择启用一个新列表来保存修改后的成员，就不会碰到这种奇怪的问题。

### 3.3.6 编写推导式的两个“不要”

01. 别写太复杂的推导式

02. 别把推导式当作代码量更少的循环

推导式的核心意义在于它会返回值——一个全新构建的列表。

如果你不需要这个新列表，就失去了使用表达式的意义。



```python
[process(task) for task in tasks if not task.started]
```

```python
for task in tasks:
    if not task.started:
        process(task)
```


### 3.3.7 让函数返回NamedTuple

对于未来可能会变动的多返回值函数来说，

```python
def latlon_to_address(lat, lon):
    """返回某个经纬度的地理位置信息"""
    ...
    # 返回多个结果——其实就是一个元组
    return country, province, city

# 所有的调用方都会这样将结果一次解包为多个变量
country, province, city = latlon_to_address(lat, lon)
```

使用NamedTuple 类型对返回结果进行建模，

```python
from typing import NamedTuple

class Address(NamedTuple):
    """地址信息结果"""
    country: str
    province: str
    city: str

def latlon_to_address(lat, lon):
    return Address(
        country=country,
        province=province,
        city=city,
    )

addr = latlon_to_address(lat, lon)
# 通过属性名来使用addr
# addr.country / addr.province / addr.city
```