# 第五章 异常与错误处理

异常实际上是Python这门编程语言里许多核心机制的基础。

## 5.1 基础知识

### 5.1.1 优先使用异常捕获

```python
def incr_by_one(value):
    """对输入整数加1，返回新的值

    :param value: 整型，或者可以转成整型的字符串
    :return: 整型结果
    """
    if isinstance(value, int):
        return value + 1
    elif isinstance(value, str) and value.isdigit():
        return int(value) + 1
    else:
        print(f'Unable to perform incr for value: "{value}"')
```

在`incr_by_one()`函数里，因为参数value可能是任意类型，所以我写了两个条件分支来避免程序报错：

1. 判断仅当类型是`int`时才执行加法操作；

2. 判断仅当类型是`str`, 同时满足`.isdigit()`方法时才进行操作。

这几行代码代表了一种编程风格：LBYL(look before you leap) 翻译为“三思而后行”。

就是在执行一个可能会出错的操作时，先做一些关键的条件判断，仅当条件满足时才进行操作。

LBYL 之外，还有另一种与之形成鲜明对比的风格：EAFP（easier to ask forgiveness than permission), 可直译为“获取原谅比许可简单”。

**EAFP**

EAFP 指不做任何事前检查，直接执行操作，但在外层用try来捕获可能发生的异常。

如果遵循EAFP风格，`incr_by_one()`函数可以改成下面这样：

```python
def incr_by_one(value):
    """对输入整数加1，返回新的值

    :param value: 整型，或者可以转成整型的字符串
    :return: 整型结果
    """
    try:
        return int(value) + 1
    except (TypeError, ValueError) as e:
        print(f'Unable to perform incr for value: "{value}", error: {e}')
```

EAFP 编程风格更为简单直接，总是直奔主流程而去，把意外情况都放在异常处理`try/except`块内消化掉。

哪种编程风格更好？

我只能说，整个Python社区明显偏爱基于异常捕获的EAFP风格。

原因：略

### 5.1.2 try 语句常用知识

01. 把更精确的except语句放在前面

```python
#BaseException是一切异常类的父类，甚至包括 KeyboardInterrupt 异常
>>> issubclass(Exception, BaseException)
True
>>> issubclass(LookupError, Exception)
True
>>> issubclass(KeyError, LookupError)
True
```

上面的代码展示了一条异常类派生关系：

BaseException -> Exception -> LookupError -> KeyError

如果一个try 代码块里包含多条except，异常匹配会按照从上而下的顺序进行。这时，假如你不小心把一个比较模糊的父类异常放在前面，就会导致在下面的except永远不会被触发。

```python
def incr_by_key(d, key):
    try:
        d[key] += 1
    except Exception as e: ➊
        print(f'Unknown error: {e}')
    except KeyError:
        print(f'key {key} does not exists')
```

KeyError 分支下的内容永远不会被执行

02. 使用else 分支

```python
#同步用户资料到外部系统，仅当同步成功时发送通知消息
sync_succeeded = False
try:
    sync_profile(user.profile, to_external=True)
    sync_succeeded = True
except Exception as e:
    print("Error while syncing user profile")
if sync_succeeded:
    send_notification(user, 'profile sync succeeded')
```


```python
try:
    sync_profile(user.profile, to_external=True)
except Exception as e:
    print("Error while syncing user profile")
else:
    send_notification(user, 'profile sync succeeded')
```


上面的else 和条件分支语句里的 else 虽然是同一个词，但含义不太一样。

异常捕获语句里的else表示：**仅当try 语句块里没抛出任何异常时，才执行else分支下的内容**，效果就像在try最后增加一个标记变量一样。

03. 使用空raise语句

在处理异常时，有时我们可能仅仅想记录某个异常，然后把它重新抛出，交由上层处理。这时，不带任何参数的raise语句可以派上用场：

```python
def incr_by_key(d, key):
    try:
        d[key] += 1
    except KeyError:
        print(f'key {key} does not exists, re-raise the exception')
        raise
```

当一个空raise语句出现在except块里时，它会原封不动地重新抛出当前异常。

### 5.1.3 抛出异常，而不是返回错误

我们知道，Python里的函数可以一次返回多个值（通过返回一个元组实现）。所以，当我们要表明函数执行出错时，可以让它同时返回结果与错误信息。

```python
def create_item(name):
    """接收名称，创建 Item 对象

    :return: (对象, 错误信息)，成功时错误信息为 ''
    """
    if len(name) > MAX_LENGTH_OF_NAME:
        return None, 'name of item is too long'
    if len(get_current_items()) > MAX_ITEMS_QUOTA:
        return None, 'items is full'
    return Item(name=name), ''


def create_from_input():
    name = input()
    item, err_msg = create_item(name)
    if err_msg:
        print(f'create item failed: {err_msg}')
    else:
        print('item<{name}> created')
```

乍看上去，这种做法似乎很自然，对那些有Go语言编程经验的人来说更是如此。**但在Python世界里，返回错误并非解决此类问题的最佳办法**。

这是因为这种做法会增加调用方处理错误的成本，尤其是当许多函数遵循这个规范，并且有很多层调用关系时。

```python
class CreateItemError(Exception):
    """创建 Item 失败"""


def create_item(name):
    """创建一个新的Item

    :raises: 当无法创建时抛出 CreateItemError
    """
    if len(name) > MAX_LENGTH_OF_NAME:
        raise CreateItemError('name of item is too long')
    if len(get_current_items()) > MAX_ITEMS_QUOTA:
        raise CreateItemError('items is full')
    return Item(name=name), ''


def create_from_input():
    name = input()
    try:
        item = create_item(name)
    except CreateItemError as e:
        print(f'create item failed: {e}')
    else:
        print(f'item<{name}> created')
```

用抛出异常替代返回错误后，整个代码结构乍看上去变化不太，但细节上的改变其实非常多。

- 新函数拥有更稳定的返回值类型，它永远只会返回item类型或是抛出异常
- 虽然我们鼓励使用异常，但异常总是会不可避免地让人“感到惊讶”， 所以，最好在函数文档里说明可能抛出的异常类型。
- 不同于返回值，异常在被捕获前会不断往调用栈上层汇报。假如程序缺少一个顶层的统一异常处理逻辑，那么某个被所有人忽视了的异常可能会层层上报，最终弄垮整个程序。

**处理异常的题外话**

像上面不推荐的多返回值方式，正是缺乏异常的Go语言中的核心错误处理机制。

另外，即使是异常机制本身，在不同编程语言之间也存在差别。比如Java的异常机制就和Python里的很不一样。

### 5.1.4 使用上下文管理器

当Python程序员们谈到异常处理时，第一个想到的往往是try语句。

但除了try以外，还有一个关键字和异常处理也有着密切的关系，就是`with`。

```python
#使用with 打开文件，文件描述符会在作用域结束后自动被释放
with open('foo.txt') as fp:
    content = fp.read()
```


`with` 是一个神奇的关键字，它可以在代码中开辟一段由它管理的上下文，并控制程序在进入和退出这段上下文时的行为。

并非所有对象都能像open('foo.txt') 一样配合`with`使用，只有满足上下文管理器（context manager）协议的对象才行。

上下文管理器是一种定义了“进入”和“退出”动作的特殊对象。

要创建一个上下文管理器，只要实现`__enter__`和`__exit__`两个魔法方法即可。

实现了一个简单的上下文管理器：

```python
class DummyContext:
    def __init__(self, name):
        self.name = name

    def __enter__(self):
        # __enter__会在进入管理器时被调用，同时可以返回结果
        # 这个结果可以通过 as 关键字被调用方获取
        #
        # 此处返回一个增加了随机后缀的name
        return f'{self.name}-{random.random()}'

    def __exit__(self, exc_type, exc_val, exc_tb):
        # __exit__会在退出管理器时被调用
        print('Exiting DummyContext')
        return False
```

```python
>>> with DummyContext('foo') as name:
...     print(f'Name: {name}')
...
Name: foo-0.021691996029607252
Exiting DummyContext
```

上下文管理器功能强大、用处很多，其中最常见的用处之一，就是简化异常处理工作。

01. 用于替代finally语句清理资源

在编写try语句时，finally关键字经常用来做一些资源清理类工作，比如关闭已创建的网络连接：

```python
conn = create_conn(host, port, timeout=None)
try:
    conn.send_text('Hello, world!')
except Exception as e:
    print(f'Unable to use connection: {e}')
finally:
    conn.close()
```

当程序使用with进入一段上下文后，无论里面发生了什么，它在退出这段上下文代码块时，必定会调用上下文管理器的__exit__方法，就和finally语句的行为一样。

因此，我们完全可以用上下文管理器来替代finally语句。

```python
class create_conn_obj:
    """创建连接对象，并在退出上下文时自动关闭"""
    def __init__(self, host, port, timeout=None):
        self.conn = create_conn(host, port, timeout=timeout)
    def __enter__(self):
        return self.conn
    def __exit__(self, exc_type, exc_value, traceback):
        # __exit__会在管理器退出时调用
        self.conn.close()
        return False
```

使用`create_conn_obj`可以创建会自动关闭的连接对象：

```python
#使用上下文管理器创建连接
with create_conn_obj(host, port, timeout=None) as conn:
    try:
        conn.send_text('Hello, world!')
    except Exception as e:
        print(f'Unable to use connection: {e}')
```

02. 用于忽略异常

在执行某些操作时，有时程序会抛出一些不影响正常执行逻辑的异常。

当你在关闭某个连接时，假如它已经是关闭状态了，解释器就会抛出AlreadyClosedError异常。这时，为了让程序正常运行下去，你必须用try语句来捕获并忽略这个异常。

```python
try:
    close_conn(conn)
except AlreadyClosedError:
    pass
```

如果使用上下文管理器，我们可以很方便地实现可复用的“忽略异常”功能——只要在__exit__方法里稍微写几行代码就行：

```python
class ignore_closed:
    """忽略已经关闭的连接"""
    def __enter__(self):
        pass
    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type == AlreadyClosedError:
            return True
        return False
```

当你想忽略AlreadyClosedError异常时，只要把代码用with语句包裹起来即可：

```python
with ignore_closed():
    close_conn(conn)
```

通过with 实现的“忽略异常”功能，主要利用了上下文管理器的__exit__方法。

在代码执行时，假如with管辖的上下文内没有抛出任何异常，那么当解释器触发__exit__方法时，上面的三个参数值都是None; 

但如果有异常抛出，这三个参数就会变成该异常的具体内容。

1. `exc_type` 异常的类型
2. `exc_value`异常对象
3. `traceback` 错误的堆栈对象

如果__exit__返回False, 那这个异常就会被正常抛出，交由调用方处理。

03. 使用contextmanager装饰器

Python 提供了一个非常好用的工具：`@contextmanager`装饰器

`@contextmanager` 位于内置模块contextlib 下，它可以把任何一个生成器函数直接转换为一个上下文管理器。

举个例子，我在前面实现的自动关闭连接的`create_conn_obj`上下文管理器，假如用函数来改成，可以简化成下面这样：

```python
from contextlib import contextmanager
@contextmanager
def create_conn_obj(host, port, timeout=None):
    """创建连接对象，并在退出上下文时自动关闭"""
    conn = create_conn(host, port, timeout=timeout)
    try:
        yield conn ➊
    finally: ➋
        conn.close()
```

1. 以yield 关键字为界，yield 前的逻辑会在进入管理器时执行(类似于__enter__), yield 后的逻辑会在退出管理器时执行（类似于__exit__）
2. 如果要在上下文管理器内处理异常，必须用try语句块包裹yield语句

在日常工作中，我们用到的大多数上下文管理器可以直接通过“生成器函数+@contextmanager”的方式来定义，这比创建一个符合协议的类要简单得多。

## 5.2 案例故事

```python
import requests
import re


def save_website_title(url, filename):
    """获取某个地址的网页标题，然后将其写入文件中

    :return: 如果成功保存，返回 True；否则打印错误，返回 False
    """
    try:
        resp = requests.get(url)
        obj = re.search(r'<title>(.*)</title>', resp.text)
        if not obj:
            print('save failed: title tag not found in page content')
            return False

        title = obj.grop（1）
        with open(filename, 'w') as fp:
            fp.write(title)
            return True
    except Exception:
        print(f'save failed: unable to save title of {url} to {filename}')
        return False


def main():
    save_website_title('https://www.qq.com', 'qq_title.txt')


if __name__== '__main__':
    main()
```

01. 小R的无心之失

但因为那段异常捕获范围过大，过于含糊，所以这个本该被抛出的AttitudeError异常被吞噬了，函数的debug过程变得难上加难：

```python
>>> obj.grop（1）
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 're.Match' object has no attribute 'grop'
```

一股脑儿地全部用except Exception： 抱起来，显然是不妥当的。

- 永远只捕获那些可能会抛出异常的语句块；
- 尽量只捕获精确的异常类型，而不是模糊的Exception；
- 如果出现了预期外的异常，让程序早点儿崩溃也未必是件坏事。

```python
import re
from requests.exceptions import RequestException
　
　
def save_website_title(url, filename):
    # 抓取网页
    try:
        resp = requests.get(url)
    except RequestException as e:
        print(f'save failed: unable to get page content: {e}')
        return False
    # 获取标题
    obj = re.search(r'<title>(.*)</title>', resp.text)
    if not obj:
        print('save failed: title tag not found in page content')
        return False
    title = obj.group（1）
    # 保存文件
    try:
        with open(filename, 'w') as fp:
            fp.write(title)
    except IOError as e:
        print(f'save failed: unable to write to file {filename}: {e}')
        return False
    else:
        return True
```

### 5.2.2 异常与抽象一致性

Django的错误页面正是利用异常机制实现的。

当需要返回错误信息给用户时，只需要做一次raise就能搞定：

```python
raise error_codes.UNABLE_TO_UPVOTE
raise error_codes.USER_HAS_BEEN_BANNED
... ...
```

01. 无法复用的process_image()函数

```python
def process_image(...):
    try:
        image = Image.open(fp)
    except Exception:
        raise error_codes.INVALID_IMAGE_UPLOADED
    ...
```

该异常会被Django中间件捕获，最终给用户返回“INVALID_IMAGE_UPLOADED” 错误码响应。

02. 避免抛出抽象级别高于当前模块的异常

图像处理模块

```python
class ImageOpenError(Exception):
    """图像打开错误异常类
    :param exc: 原始异常
    """
    def __init__(self, exc):
        self.exc = exc
        # 调用异常父类方法，初始化错误信息
        super().__init__(f'Image open error: {self.exc}')
def process_image(...):
    try:
        image = Image.open(fp)
    except Exception as e:
        raise ImageOpenError(exc=e)
    ... ...
```

API 视图模块

```python
def foo_view_function(request):
    try:
        process_image(fp)
    except ImageOpenError:
        raise error_codes.INVALID_IMAGE_UPLOADED
```

03. 包装抽象级别低于当前模块的异常

## 5.3 编程建议

### 5.3.1 不要随意忽略异常

### 5.3.2 不要手动做数据校验

在数据校验这块，`pydantic`模块是一个不错的选择。

> 假如你在开发Web应用，数据校验工作通常来说比较容易。比如Django框架就有自己的表单验证模块。
>


### 5.3.3 抛出可区分的异常

虽然这段代码通过对比错误字符串实现了需求，但这种做法其实非常脆弱。

```python
def create_from_input():
    name = input()
    try:
        item = create_item(name)
    except CreateItemError as e:
        # 如果已满，清空所有 items
        if str(e) == 'items is full':
            clear_all_items()

        print(f'create item failed: {e}')
    else:
        print(f'item<{name}> created')
```

为了解决这个问题，我们可以利用异常间的继承关系，设计一些更精确的异常子类：

```python
class CreateItemError(Exception):
    """创建 Item 失败"""


class CreateErrorItemsFull(CreateItemError):
    """当前的Item 容器已满"""


def create_item(name):
    if len(name) > MAX_LENGTH_OF_NAME:
        raise CreateItemError('name of item is too long')
    if len(get_current_items()) > MAX_ITEMS_QUOTA:
        raise CreateErrorItemsFull('items is full')
    return Item(name=name)
```

这样做以后，调用方就能用额外的except子句来单独处理"items已满"异常了。

```python
def create_from_input():
    name = input()
    try:
        item = create_item(name)
    except CreateErrorItemsFull as e:
        clear_all_items()
        print(f'create item failed: {e}')
    except CreateItemError as e:
        print(f'create item failed: {e}')
    else:
        print(f'item<{name}> created')
```

### 5.3.4 不要使用assert来检查参数合法性

assert 是 Python 中用来编写断言语句的关键字，它可以用来测试某个表达式是否成立。

```python
>>> value = 10
>>> assert value > 100
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError
```

因此，有人可能会想着拿它来检查函数参数是否合法

```python
def print_string(s):
    assert isinstance(s, str), 's must be string'
    print(s)
```

assert 是一个专供开发者调试程序的关键字。

```python
$ python -O
# -O 选项表示让所有 assert 断言语句无效化
# 开启该选项后，下面的assert 语句不会抛出任何异常
>>> assert False
```

### 5.3.5 无须处理是最好的错误处理

虽然我们学习了许多错误处理技巧，但无论如何，对于所有编写代码的程序员来说，错误处理永远是一种在代码主流程之外的额外负担。

除了在设计API时考虑减少错误以外，“空对象模式”也是一个通过转换观念来避免错误处理的好例子。

**空对象模式**

简单来说，“空对象模式”就是本该返回None值或抛出异常时，返回一个符合正常结果接口的特制“空类型对象”来代替，以此免去调用方的错误处理工作。

```python
QUALIFIED_POINTS = 80

class CreateUserPointError(Exception):
    """创建得分纪录失败时抛出"""

class UserPoint:
    """用户得分记录"""

    def __init__(self, username, points):
        self.username = username
        self.points = points

    def is_qualified(self):
        """返回得分是否合格"""
        return self.points >= QUALIFIED_POINTS

def make_userpoint(point_string):
    """从字符串初始化一条得分记录

    :param point_string: 形如piglei 1 的表示得分记录的字符串
    :return: UserPoint 对象
    :raises: 当输入数据不合法时返回 CreateUserPointError
    """
    try:
        username, points = point_string.split()
        points = int(points)
    except ValueError:
        raise CreateUserPointError(
            'input must follow pattern "{username} {points}"'
        )

    if points < 0:
        raise CreateUserPointError('points can not be negative')
    return UserPoint(username=username, points=points)

def count_qualified(points_data):
    """计算得分合格的总人数

    :param points_data: 字符串格式的用户得分列表
    """
    result = 0
    for point_string in points_data:
        try:
            point_obj = make_userpoint(point_string)
        except CreateUserPointError:
            pass
        else:
            result += point_obj.is_qualified()
    return result

data = [
    'piglei 96',
    'nobody 61',
    'cotton 83',
    'invalid_data',
    'roland $invalid_points',
    'alfred -3',
]

print(count_qualified(data))
# 输出结果：
# 2
```

假如引入“空对象模式”，上面的异常处理逻辑可以完全消失

```python
QUALIFIED_POINTS = 80

class UserPoint:
    """用户得分记录"""

    def __init__(self, username, points):
        self.username = username
        self.points = points

    def is_qualified(self):
        """返回得分是否合格"""
        return self.points >= QUALIFIED_POINTS

class NullUserPoint:
    """一个空的用户得分记录"""

    username = ''
    points = 0

    def is_qualified(self):
    return False

def make_userpoint(point_string):
    """从字符串初始化一条得分记录

    :param point_string: 形如piglei 1 的表示得分记录的字符串
    :return: 如果输入合法，返回 UserPoint 对象，否则返回 NullUserPoint
    """
    try:
        username, points = point_string.split()
        points = int(points)
    except ValueError:
        return NullUserPoint()

    if points < 0:
        return NullUserPoint()
    return UserPoint(username=username, points=points)
```

在新版代码里，我定义了一个代表“空得分记录”的新类型：`NullUserPoint`, 每当`make_userpoint()`接收到无效的输入，执行失败时，就会返回一个NullUserPoint对象。

> 在Python世界中，"空对象模式"并不少见，比如大名鼎鼎的Django框架里的AnonymousUser设计就应用了这个模式。