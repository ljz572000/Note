
# 2. 数值与字符串

Python 整型不必担心任何溢出问题。

## 2.1 基础知识

内置数值类型：整型、浮点和复数

在定义数值字面量时，如果数字特别长，可以通过插入_分隔符来让它变得更易读

```python
#以"千"为单位分隔数字
>>> i = 1_000_000
>>> i + 10
1000010
```

浮点精度问题。为了解决这个问题，Python提供了一个内置模块：decimal.

在使用Decimal的过程中，大家需要注意：必须使用字符串来表示数字。会掉进所谓的“浮点数陷阱”

```python
>>> 0.1 + 0.2
0.30000000000000004
```

### 2.1.2 布尔值其实也是数字

布尔类型其实时整型的子类型，在绝大多数情况下，True和False 这两个布尔值可以直接当作1和0来使用。

```python
>>> int(True), int(False)
(1, 0)
>>> True + 1
2

# 把 False 当除数的效果和0 一样
>>> 1 / False
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
```

利用“布尔值可作为整型使用”的特性，一个简单的表达式就能完成同样的事情

```python
count = sum( i % 2 == 0 for i in numbers)
```

### 2.1.3 字符串常用操作

**01. 把字符串当序列来操作**

```python
>>> s = 'Hello, world!'
>>> for c in s: ➊
...     print(c)
...
H
...
d
!
>>> s[1:3] ➋
'el'
```

**02. 字符串格式化**

```python
username, score = 'piglei', 100
# 1. C 语言风格格式化
print('Welcome %s, your score is %d' % (username, score))
# 2. str.format
print('Welcome {}, your score is {:d}'.format(username, score))
# 3. f-string，最短最直观
print(f'Welcome {username}, your score is {score:d}')
# 输出：
# Welcome piglei, your score is 100
```

通过这种微语言，我们可以方便地对字符串进行二次加工，然后输出

```python
#将 username靠右对齐，左侧补空格到一共 20个字符
# 以下两种方式将输出同样的内容
print('{:>20}'.format(username))
print(f'{username:>20}')
# 输出：
#               piglei
```

**03.拼接多个字符串**

`str.join` or `+=`

### 2.1.4 不常用但特别好用的字符串方法

- s.isdigit()

- str.partition(sep) 

按照分隔符sep切分字符串，返回一个包含三个成员的元组

分隔符前的内容，分隔符以及分隔符后的内容。


## 2.2 案例故事

### 2.2.1 代码里的密码

- 更易读：所有人都不需要记忆某个数字代表什么
- 更健壮：降低输错数字或字母产生bug的可能性

### 2.2.2 别轻易成为SQL语句“大师”

```python
def fetch_users(
    conn,
    min_level=None,
    gender=None,
    has_membership=False,
    sort_field="created",
):
    """获取用户列表

    :param min_level: 要求的最低用户级别，默认为所有级别
    :type min_level: int, optional
    :param gender: 筛选用户性别，默认为所有性别
    :type gender: int, optional
    :param has_membership: 筛选会员或非会员用户，默认为 False，代表非会员
    :type has_membership: bool, optional
    :param sort_field: 排序字段，默认为 "created"，代表按用户创建日期排序
    :type sort_field: str, optional
    :return: 一个包含用户信息的列表：[(User ID, User Name), ...]
    """
    # 一种古老的SQL 拼接技巧，使用“WHERE 1=1”来简化字符串拼接操作
    statement = "SELECT id, name FROM users WHERE 1=1"
    params = []
    if min_level is not None:
        statement += " AND level >= ?"
        params.append(min_level)
    if gender is not None:
        statement += " AND gender >= ?"
        params.append(gender)
    if has_membership:
        statement += " AND has_membership = true"
    else:
        statement += " AND has_membership = false"

    statement += " ORDER BY ?"
    params.append(sort_field)
    # 将查询参数 params 作为位置参数传递，避免 SQL 注入问题
    return list(conn.execute(statement, params))
```

**01. 使用SQLAlchemy模块改写代码**

上述函数所做的事情，我习惯称之为“裸字符串处理”

```python
def fetch_users_v2(
    conn,
    min_level=None,
    gender=None,
    has_membership=False,
    sort_field="created",
):
    """获取用户列表"""
    query = select([users.c.id, users.c.name])
    if min_level != None:
        query = query.where(users.c.level >= min_level)
    if gender != None:
        query = query.where(users.c.gender == gender)
    query = query.where(users.c.has_membership == has_membership).order_by(
        users.c[sort_field]
    )
    return list(conn.execute(query))
```

新的fetch_users_v2() 函数不光更短、更好维护，而且根本不需要担心SQL注入问题。

**02. 使用Jinja2 模板处理字符串**

略

## 2.3 编程建议

### 2.3.1 不必预计计算字面量表达式

```python
def do_something(delta_seconds):
    # 如果时间已经过去11 天（或者更久），不做任何事
    if delta_seconds > 950400:
        return
    ...
```

```python
if delta_seconds < 11 * 24 * 3600
```
预先算出算式的结果，函数也不会多出任何额外开销。

因此，当我们需要用到复杂计算的数字字面量时，请保留整个算式吧。

### 2.3.2 使用特殊数字：“无穷大”

### 2.3.3 改善超长字符串的可读性
### 2.3.4 别忘了以r开头的字符串内置方法

`.rsplit()`

### 2.3.5 不要害怕字符串拼接

如今，使用`+=`拼接字符串基本已经和“”.join(str_list)一样快了。



