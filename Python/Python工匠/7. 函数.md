## 7.1 基础知识

### 7.1.1 函数参数的常用技巧

01. 别将可变类型作为参数默认值
02.  定义特殊对象来区别是否提供了默认参数
03.   定义仅限关键字参数

### 7.1.2 函数返回的常见模式

01. 尽量只返回一种类型

02. 谨慎返回None值

03. 早返回，多返回

### 7.1.3 常用函数模块：functools

在Python标准库中，有一些与函数关系紧密的模块，其中最有代表性的当属functools.

functools 是一个专门用来处理函数的内置模块。

01. functools.partial()

```python
def multiply(x, y):
    return x * y
```

当你调用`partial(func, True, foo=1)`后，函数会返回一个新的可调用对象（callable object）- 偏函数partial_obj.

如果你不带任何参数调用它，效果等同于使用构建partial_obj对象时的参数调用原函数：`partial_obj()`等同于`func(True, foo=1)`

```python
import functools
double = functools.partial(multiply, 2)
```


02. functools.lru_cache()

在编码时，我们的函数常常需要做一些耗时较长的操作，比如调用第三方API。这些操作会导致函数执行速度慢，无法满足要求。

为了提高效率，给这类慢函数加上缓存是比较常见的做法。

在缓存方面，functools模块为我们提供一个开箱即用的工具：`lru_cache()`。可以方便地给函数加上缓存功能，同时不用修改任何函数内部代码。

```python
def calculate_score(class_id):
    print(f'Calculating score for class: {class_id}...')
    # 模拟此处存在一些速度很慢的统计代码……
    time.sleep(60)
    return 42
```

```python
@lru_cache(maxsize=None)
def calculate_score(class_id):
    print(f'Calculating score for class: {class_id}...')
    time.sleep(60)
    return 42
```

```python
>>> calculate_score(100)
# 缓存未命中，耗时较长
Calculating score for class: 100...
42
# 第二次使用同样的参数调用函数，就不会触发函数内部的计算逻辑，
# 结果立刻就返回了。
>>> calculate_score(100)
42
```

在使用lru_cache()装饰器时，可以传入一个可选的maxsize参数，该参数代表当前函数最多可以保存多少个缓存结果。

默认情况下，maxsize的值为128

如果你把maxsize设置为None，函数就会保存每一个执行结果，不再剔除任何旧缓存，存在占用过多内存的风险。

## 7.2 案例故事

### 函数与状态

虽然全局变量能满足需求，但是用全局变量保存状态，其实是写代码时最应该避开的事情之一。

首先，上面这种方式非常脆弱。如果多个模块在不同线程里，整个字符转换的逻辑就会乱掉，因为多个调用方共享同一个全局标记变量。

第二次调用，因为全局标记没有被充值。

除了全局变量以外，小R还可以使用另一个办法：闭包

**闭包**

闭包（closure）是编程语言领域里的一个专有名词。

简单来说，闭包是一种允许函数访问已执行完成的其他函数里的私有变量的技术，是为了函数增加状态的另一种方式。

正常情况下，当Python完成一次函数执行后，本次使用的局部变量都会在调用结束后被回收，无法继续访问。

但是，如果你使用下面这种“函数套函数”的方式，在外层函数执行结束后，返回内嵌函数，后者就可以继续访问前者的局部变量，形成一个“闭包”结构


```python
def counter():
    value = 0
    def _counter():
        # nonlocal 用来标注变量来自上层作用域，如不标明，内层函数将无法直接修改外层函数变量
        nonlocal value
        value += 1
        return value
    return _counter
```

总而言之，闭包是一种非常有用的工具，非常适合用来实现简单的有状态函数。

05. 给函数加上状态：类

类（class）是面向对象编程里最基本的概念之一。

在一个类中，状态和行为可以被很好地封装在一起，因此它天生合适用来实现有状态对象。

```python
class CyclicMosaic:
    """使用会轮换的屏蔽字符，基于类实现"""
    _chars = ['*', 'x']
    def __init__(self):
        self._char_index = 0 ➊
    def generate(self, matchobj):
        char = self._chars[self._char_index]
        self._char_index = (self._char_index + 1) % len(self._chars)
        length = len(matchobj.group())
        return char * length
```

```python
>>> re.sub(r'\d+', CycleMosaic().generate, '商店共 100个苹果，小明以12 元每斤的价格买走了8个')
'商店共 *** 个苹果，小明以xx 元每斤的价格买走了* 个'
```

使用类和闭包一样，也可以很好地满足需求。

06. 总结

- 基于全局变量
  - 学习成本最低，最容易理解
  - 会增加模块级的全局状态，封装性和可维护性最差
- 基于函数闭包
  - 学习成本适中，可读性较好
  - 适合用来实现变量较少，较简单的有状态函数
- 创建类来封装状态
  - 学习成本较高
  - 当变量较多、行为较复杂时，类代码比闭包代码更易读，也更容易维护。

**在日常编码中，如果你需要实现有状态的函数，应该尽量避免使用全局变量，闭包或类才是更好的选择。**

## 7.3 编程建议

### 7.3.1 别写太复杂的函数

什么样的函数才能算是过于复杂？

01. 长度

第一个标准是长度，也就是函数有多少行代码。

在著作《代码大全（第二版）》中，Steve McConnell 提到函数的理想长度范围是65到200行，一旦超过200行，代码出现bug的概率就会显著增加。

对于Python这种强表现力的语言来说，65行已经非常值得警惕了。

超过65行，请考虑将它拆分为多个小而简单的子函数（类）吧。

02. 圈复杂度

代表程序内线性独立路径的数量。圈复杂度的值越大，表示程序可能的执行路径就越多，逻辑就越复杂。

在Python中，你可以通过radon工具计算一个函数的圈复杂度。radon基于Python编写

```python
def rank(self):
    rating_num = float(self.rating)
    if rating_num >= 8.5:
        return 'S'
    elif rating_num >= 8:
        return 'A'
    elif rating_num >= 7:
        return 'B'
    elif rating_num >= 6:
        return 'C'
    else:
        return 'D'
```


```python
> radon cc complex_func.py -s
complex_func.py
    F 1:0 rank - A （5）
```

可以看到，有着大段if/elif的rank() 函数的圈复杂度为5，评级为A。虽然这个值没有达到危险线10，但考虑到函数只有短短10行，5已经足够引起重视了。

```python
def rank(self):
    breakpoints = (6, 7, 8, 8.5)
    grades = ('D', 'C', 'B', 'A', 'S')
    index = bisect.bisect(breakpoints, float(self.rating))
    return grades[index]
```

新函数的圈复杂度从5降为1.

如果一个函数的圈复杂度为1，就代表这个函数只有一条主路径，没有任何其他执行路径，这样的函数通常来说十分简单、容易维护。

```python
radon cc complex_func.py -s
complex_func.py
    F 1:0 rank - A （1）
```

这种检查配置到开发或部署流程中自动执行。

### 7.3.2 一个函数只包含一层抽象

#### 01. 什么是抽象

抽象就是一种选择特征、简化认知的手段。

#### 02. 抽象与软件开发

#### 03. 脚本案例：调用API查找歌手的第一张专辑

#### 04. 脚本抽象级别分析

#### 05. 基于抽象层重构代码

### 7.3.3 优先使用列表推导式

### 7.3.4 你没有那么需要lambda

### 7.3.5 了解递归的局限性

## 7.4 总结

