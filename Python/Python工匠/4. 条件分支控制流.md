# 4. 条件分支控制流

## 4.1 基础知识

### 4.1.1 分支惯用写法


当我们编写分支时，第一件要注意的事情，就是不要显示地和布尔值做比较：

```python
#不推荐的写法
# if user.is_active_member() == True:

# 推荐写法
if user.is_active_member():
```

绝大多数情况下，在分支判断语句里写==True都没有必要，删掉它代码会更短也更易读。

01. 省略零值判断

```python
if containers_count == 0:
    ...
if fruits_list != []:
    ...
```

代码简化

这样的条件判断更简洁，也更符合Python社区的习惯。

```python
if not containers_count:
    ...
if fruits_list:
    ...
```

这样写会放宽分支判断的成立条件

```
#更精准：只有为 0的时候，才会满足分支条件
if containers_count == 0:
    ....
# 更宽泛：当 containers_count 的值为 0、None、空字符串等时，都可以满足分支条件
if not containers_count:
    ...
```

布尔值为假：`None、0、False、[]、()、{}、set()、frozenset()`, 等等。

布尔值为真：`非0的数值、True、非空的序列、元组、字典、用户定义的类和实例，等等。`

02. 把否定逻辑移入表达式

```python
if not number < 10:
    ...
if not current_user is None:
    ...
if not index == 1:
    ...
```

```python
if number >= 10:
    ...
if current_user is not None:
    ...
if index != 1:
    ...
```

03. 尽可能让三元表达式保持简单

当你在编写三元表达式时，不要盲目追求用一个表达式来表达太过于复杂的逻辑。



```python
#语法：
# true_value if <expression> else false_value
language = "python" if you.favor("dynamic") else "golang"
```

### 4.1.2 修改对象的布尔值

```python
class UserCollection:
    """用于保存多个用户的集合工具类"""

    def __init__(self, users):
        self.items = users

users = UserCollection(['piglei', 'raymond'])

# 仅当用户列表里面有数据时，打印语句
if len(users.items) > 0:
    print("There's some users in collection!")
```

但其实，上面的分支判断语句可以变得更简单。

只要给UserCollection类实现_len_魔法方法，users对象就可以直接用于“真值测试”

```python
class UserCollection:
    """用于保存多个用户的集合工具类"""

    def __init__(self, users):
        self.items = users

    def __len__(self):
        return len(self.items)

users = UserCollection(['piglei', 'raymond'])

# 不再需要手动判断对象内部 items 的长度
if users:
    print("There's some users in collection!")
```

```python
>>> users = UserCollection([])
>>> len(users)
0
>>> users = UserCollection(['piglei', 'raymond'])
>>> len(users)
2
```

不过，定义__len__并非影响布尔值结果的唯一办法。

除了__len__以外，还有一个魔法方法__bool__和对象的布尔值息息相关。

```python
class ScoreJudger:
    """仅当分数大于60 时为真"""

    def __init__(self, score):
        self.score = score

    def __bool__(self):
        return self.score >= 60
```


```python
>>> bool(ScoreJudger(60))
True
>>> bool(ScoreJudger(59))
False
```

### 4.1.3 与None 比较时使用is运算符

如何严格检查某个对象是否为None呢？

答案是使用is运算符。 虽然二者看上去差不多，但有着本质上的区别：

1. ==对比两个对象的值是否相等，行为可被__eq__方法重载；

2. is判断两个对象是否是内存里的同一个东西，**无法被重载**。

换句话说，当你在执行`x is y`时， 其实就是在判断id(x)和id(y)的结果是否相等，二者是否是同一个对象。

因此，当你想要判断某个对象是否为None时，应该使用is运算符

```python
>>> foo = EqualWithAnything()
>>> foo == None
True

# is 的行为无法被重载
>>> foo is None
False

# 有且仅有真正的None 才能通过 is 判断
>>> x = None
>>> x is None
True
```

除了None、True 和 False 这三个内置对象之外，其他类型的对象在Python中并不是严格以单例模式存在的。换句话说，即便值一致，它们在内存中仍然是完全不同的两个对象。


```python
>>> x = 6300
>>> y = 6300
>>> x is y
False

# 它们在内存中是不同的两个对象
>>> id(x), id(y)
(4412016144, 4412015856)

# 进行值判断会返回相等
>>> x == y
True
```

整型驻留技术

假如我们稍微调整一下上面的代码。把数字从6300改成100，会获得完全相反的执行结果。

```python
>>> x = 100
>>> y = 100
>>> x is y
True
# 二者 id 相等，在内存中是同一个对象
>>> id(x), id(y)
(4302453136, 4302453136)
```

对于从-5到256的这些常用小整数，Python会将它们缓存在内存里的一个数组中。

当你的程序需要用到这些数字时，Python不会创建任何新的整型对象，而是会返回缓存中的对象。这样能为程序节约内存。


## 4.2 案例故事

01. 使用bisect优化范围分支判断

```python
@property
def rank(self):
    rating_num = float(self.rating)
    if rating_num >= 8.5:
        return 'S'
    elif rating_num >= 8:
        return 'A'
    elif rating_num >= 7:
        return 'B'
    elif rating_num >= 6:
        return 'C'
    else:
        return 'D'
```

bisect 是Python 内置的二分算法模块，他有一个同名函数bisect, 可以用来在有序列表里做二分查找

```python
>>> import bisect
# 注意：用来做二分查找的容器必须是已经排好序的
>>> breakpoints = [10, 20, 30]
# bisect 函数会返回值在列表中的位置，0 代表相应的值位于第一个元素 10 之前
>>> bisect.bisect(breakpoints, 1)
0
# 3 代表相应的值位于第三个元素 30 之后
>>> bisect.bisect(breakpoints, 35)
3
```

```python
@property
def rank(self):
    # 已经排好序的评级分界点
    breakpoints = (6, 7, 8, 8.5)
    # 各评分区间级别名
    grades = ('D', 'C', 'B', 'A', 'S')
    index = bisect.bisect(breakpoints, float(self.rating))
    return grades[index]
```

02. 使用字典优化分支代码

```python
def get_sorted_movies(movies, sorting_type):
    if sorting_type == 'name':
        sorted_movies = sorted(movies, key=lambda movie: movie.name.lower())
    elif sorting_type == 'rating':
        sorted_movies = sorted(
            movies, key=lambda movie: float(movie.rating), reverse=True
        )
    elif sorting_type == 'year':
        sorted_movies = sorted(
            movies, key=lambda movie: movie.year, reverse=True
        )
    elif sorting_type == 'random':
        sorted_movies = sorted(movies, key=lambda movie: random.random())
    else:
        raise RuntimeError(f'Unknown sorting type: {sorting_type}')
    return sorted_movies
```

相比之前的大段 if/elif, 新代码变得整齐了许多，扩展性也更强了。如果要增加新的排序算法，我们只需要在sorting_algos字典里增加新成员即可。

```python
def get_sorted_movies(movies, sorting_type):
    """对电影列表进行排序并返回
    :param movies: Movie 对象列表
    :param sorting_type: 排序选项，可选值
        name（名称）、rating（评分）、year（年份）、random（随机乱序）
    """
    sorting_algos = {
        # sorting_type: (key_func, reverse)
        'name': (lambda movie: movie.name.lower(), False),
        'rating': (lambda movie: float(movie.rating), True),
        'year': (lambda movie: movie.year, True),
        'random': (lambda movie: random.random(), False),
    }
    try:
        key_func, reverse = sorting_algos[sorting_type]
    except KeyError:
        raise RuntimeError(f'Unknown sorting type: {sorting_type}')
    sorted_movies = sorted(movies, key=key_func, reverse=reverse)
    return sorted_movie
```


优化之后代码

```python
import bisect
import random
class Movie:
    """电影对象数据类"""
    def __init__(self, name, year, rating):
        self.name = name
        self.year = year
        self.rating = rating
    @property
    def rank(self):
        """
        按照评分对电影分级
        """
        # 已经排好序的评级分界点
        breakpoints = (6, 7, 8, 8.5)
        # 各评分区间级别名
        grades = ('D', 'C', 'B', 'A', 'S')
        index = bisect.bisect(breakpoints, float(self.rating))
        return grades[index]
　
　
def get_sorted_movies(movies, sorting_type):
    """对电影列表进行排序并返回
    :param movies: Movie 对象列表
    :param sorting_type: 排序选项，可选值
        name（名称）、rating（评分）、year（年份）、random（随机乱序）
    """
    sorting_algos = {
        # sorting_type: (key_func, reverse)
        'name': (lambda movie: movie.name.lower(), False),
        'rating': (lambda movie: float(movie.rating), True),
        'year': (lambda movie: movie.year, True),
        'random': (lambda movie: random.random(), False),
    }
    try:
        key_func, reverse = sorting_algos[sorting_type]
    except KeyError:
        raise RuntimeError(f'Unknown sorting type: {sorting_type}')
    sorted_movies = sorted(movies, key=key_func, reverse=reverse)
    return sorted_movies
```


## 4.3 编程建议

### 4.3.1 尽量避免多层分支嵌套

记住一句话：**要竭尽所能地避免分支嵌套**

“提前返回”指的是：当你在编写分支时，首先找到那些会中断执行的条件，把它们移到函数最前面，然后再分支里直接使用return或raise结束执行

### 4.3.2 别写太复杂的条件表达式

### 4.3.3 尽量降低分支内代码的相似性

为了降低这种相似性，我们可以使用python函数的动态关键字参数（**kwargs）特性，

### 4.3.4 使用“德摩根定律”

当我们需要表达包含许多“否定逻辑”时，这时就该“德摩根定律”

```python
#如果用户没有登录或者用户没有使用Chrome，拒绝提供服务
if not user.has_logged_in or not user.is_from_chrome:
    return "our service is only available for chrome logged in user"
```


```python
if not (user.has_logged_in and user.is_from_chrome):
    return "our service is only available for chrome logged in user"
```

### 4.3.5 使用all() / any() 函数构建条件表达式

all() 和 any() 特别适合在构建条件表达式时使用

- all(iterable) 仅当iterable 中所有的成员的布尔值都为真时返回True, 否则返回False.
- any(iterable) 只要iterable中任何一个成员的布尔值为真就返回True, 否则返回False

```python
def all_numbers_gt_10(numbers):
    """仅当序列中所有数字都大于10 时，返回 True"""
    if not numbers:
        return False

    for n in numbers:
        if n <= 10:
            return False
    return True
```

```python
def all_numbers_gt_10_2(numbers):
    return bool(numbers) and all(n > 10 for n in numbers)
```

### 4.3.6 留意and和or的运算优先级

### 4.3.7 避开or运算符的陷阱

or 最有趣的地方是它的“短路求值”特性