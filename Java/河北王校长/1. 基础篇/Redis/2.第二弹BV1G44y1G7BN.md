# Redis 持久化

分为RDB（Redis Database ）（快照）和AOF(Append Only File)（只追加文件）.

生产中，一般都需要RDB和AOF同时开启，以确保最大程度上的持久化到所有的数据的变更。

RDB持久化有两种形式，save和bgsave.

RDB和AOF同时开启, 如果redis进行重启，优先加载AOF文件。AOF文件能够更加细粒度的控制我们redis他的一个数据周期，

# RDB

其实就是一个磁盘式的持久化。

RDB 持久化有两种形式，save 和 bgsave

save 模式目前来说，很少有企业使用。

因为save会造成，如果我当前的redis在执行save命令去生成我们的快照文件的话，对于其他redis 的请求，完全会被阻塞。拒绝掉。

bgsave 会从主线程中fork出一个子进程，进程中保存的是fork子进程时，redis主进程中的所有保存的数据，并以这个时间点的数据进行rdb文件的生成

正在进行bgsave,如果又来了一个save 操作，或者又来了一个bgsave操作。那么这个两个操作都会被拒绝掉，

因为 save 不能与bgsave 共存，bgsave 也不能与bgsave共存

正在进行bgsave,如果又来了一个write off AOF 操作, 这个时候redis 不会拒绝。但是你需要排队。先完成bgsave, 我再去重写你的AOF文件。

再去重写你的AOF文件，如果又来了一个bgsave, 会遭到拒绝。

> 如果在进行AOF的过程当中, 一定要选择我们业务需求不是非常多的情况下。
> 如果我们业务非常多，会触及redis 的save操作。
> 900秒至少1次访问要进行一次bgsave，300秒如果有至少10次访问进行bgsave， 60秒有至少10000次访问对redis的修改进行bgsave.  
>  900秒（15分钟）至少1次访问(增删改)要进行一次bgsave， 除非没有进行访问
> 要选择业务时间段比较少的时候，以防在重写aof文件的过程中，服务器达到了我们save的指标，自动进行了bgsave的发送。
> 这个bgsave 就会被拒绝掉

# RDB bgsave 提供了三种选项

第一个选项是时间，第二个选项是次数。

Redis 底层代码里面有一个参数叫save_pamas, 这样的一个数据结构，可以把它看成是一个对象。

对象里第一个选项，time_t （以second为单位结尾）对应900、300、60

第二个选项是int_changes，changes-->修改次数。但是这个次数不包括查询，只包括增删改。对应我们之前提到的1，10，10000.

dirty计数器， 记录修改次数   add 1   add 2  add 3   计数器为3.

lastsave time  看是否达到我们所说的60秒 300秒 900秒，然后再加上我们dirty计数器 看是否达到 1 10 10000。所说均为默认配置。


# RDB 文件的数据结构

开头的五个字节，就是写死的Redis.  这就代表了他是RDB文件。

之后是四个字节，RDB version，标记这是第几版。 

第三部分，database 里面的数据

第四部分，EOF（当前RDB文件的结尾），标记database 数据Load完成，并不代表RDB文件是完好无损的。

EOF后边又跟了八个字节的校验和

问什么叫校验和。前面这几部分加起来。看是否相等，如果不完整，叫当前文件受损。Redis启动加载文件失败。


如果没有开启AOF的情况下，Redis重启了，Redis会直接去检索硬盘上的RDB文件。如果有这个文件Redis自动进行读取，不需要人工手动进行触发。这个是RDB的Redis 读取方式。

如果AOF开启的话，优先读取AOF文件。

# AOF 只追加文件

保存真正的redis 执行命令。

缺点：数据量太大

AOF 里边包含三步。

第一步，命令追加。追加到aof_buf 里边。

第二步，文件写入，aof_buf 中记录的指令写入到aof文件当中，类似于MySQL的日志写入机制。

第三步，文件同步，aof文件刷写到磁盘，aof的同步机制有三种，分别为always(每个时间循环都进行同步)、everysec(每秒都进行同步，写入buff)(目前企业使用的这个)、no(交由操作系统进行文件同步)

always 也会丢失命令，丢失当前执行，且未执行完毕的命令。

everysec 会丢失一秒命令。

说白了不是使用单节点的redis, 使用的是redis 集群。

## AOF 文件是如何被redis 加载上来的

会创建伪客户端来模拟导入。

## 对于AOF文件的重写

在业务不繁忙时进行

对于AOF文件的重写（write off aof），也会和bgsave一样在fork出的子进程中进行操作。

重写时，是以保存时的时间为节点，进行相应命令的重写，如果出现重写开始后有新的数据改变的情况，除了会将改动命令写入到aof_buf中，还会将命令写入重写aof缓冲区（为了保证不丢失任何命令）。

待子进程重写完毕后，发送通知信号到父进程，由父进程再阻塞式的将重写aof_buf 中的命令追加到新的aof文件中，然后再将老的aof文件进行覆盖。


重复的命令，例如 add delete 1000 次， 新的aof文件中会没有东西，会转化成比较简练的语句。

对于我们同一条AOF命令，会多几条命令？

list 数据集可能会非常大，会造成命令行处理缓冲区溢出。因此会进行拆分，插入。
