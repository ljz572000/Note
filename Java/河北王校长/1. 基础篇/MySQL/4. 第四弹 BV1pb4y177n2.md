# MySQL为什么要使用B+树，不使用跳表

跳表的数据结构其实基于我们的这个链式结构，而引出的跳表结构

比如说我们有四个字，

1-》2-》3-》4

对于跳表来说，除了上面基本的链接结构之外，他还可以进行1到3的一个直接链接，也可以进行1到4的一个直接链接，

那么这样来说，从第一个节点，我们就有多个指针，指向不同的next节点。

如果我们要把这个节点指针设计的比较好的话，比如说我们要检索3，我们可以从1-》3，进行next 指针的一个调用。

那么它的查询复杂度是O(n).

跳过某些不需要查询的这些点，那么这n的值会非常小，从而带来一个比较大的一个性能的提升。

但是为什么MySQL不用这个。

其中一个比较重要的点是我们MySQL持久化存储的一个介质在哪里，在磁盘里边。

链式结构它的结构，存放在哪里？存放在我们的内存里边

而且MySQL，他进行我们数据的这个索引的时候，他是直接以块的形式，就是我们所说的MySQL 16kb 内存页，然后再内存页里边再进行这个定位。

1. 跳表使用的是我们链表里面Node的一个节点，而且它的指针管理非常的复杂，已经不适用我们磁盘存储介质

2. MySQL里边涉及的查询比较多，比较复杂。

就举个例子啊。如果我们联合索引，联合索引使用跳表的话，大家可以想一想。

如果有两个字段做联合索引，首先我们要按首字段，第一个字段进行排序，基于他的基础上，再对第二个字段进行排序。

如果我们使用跳表的话，会非常恐怖。

我们除了要维护第一个节点的指针，跳跃指针，多个跳跃指针。

我们还要想办法维护第二个节点，第二个索引字段的这个跳跃指针。

那么这才是两个呀。

> hashmap 时间复杂度O(1)

# MySQL里边的日志系统

## MySQL插入性能

非常高并发的批量插入数据的话，他有什么性能的一个瓶颈呢？

首先，我们面临的最大的一个瓶颈就是我们MySQL的id 自增长

id 不重复，因为有锁。有锁就涉及block, 涉及性能问题。

所以它的id自增，是我们MySQL进行批量插入的一个比较大的性能瓶颈。

那么MySQL是怎么做的呢？

MySQL 5.1.22 之前， 他对于所有的插入，auto_increase_locking  他是一个轻量级锁，他并不是一个重量级锁。

这个锁用来锁定innodb里边有一个自增长计数器。

也就是说他需要保证这个计数器，线程是安全的。

锁释放的时机是什么时候呢?

他的时机是a 插入完SQL，提交之前进行锁的释放。

事务的提交涉及MySQL持久化的问题。提交之后，他才是被认可的，非中间状态非临时状态的这种可持久化的这种数据。

我们知道MySQL持久化是做到磁盘里边的，他就有时间的消耗。

如果commit 已完，再做锁的释放，那对于我们另外一条线程，至少要等待的时间，增加持久化的时间对吧。

他只要插入了，只要执行完了这条SQL语句了。哪怕没有进行最终的持久化commit提交，我们就可以把这个锁进行一个释放。

在这个基础上，再进行ID的自增。

MySQL 5.1.22 之后， 第一种模式还是auto_increase_locking，第二种模式（默认MySQL自增长计数器锁定的这个策略），如果在已知插入数据数量的前提下，采用互斥量，进行我们id自增长

什么是互斥量？

听到互斥量，类似于锁的概念，但是比轻量级锁更加轻量

10条数据，不需要10次block, 这是一个非常大的一个性能提升。

在未知数条数的情况下，还是使用之前的模式auto_increase_locking

> 如果主键Id不连续，将直接威胁到你的MySQL的主从复制问题。
> 不同节点，查询数据不一致，那可就要命了。
>




