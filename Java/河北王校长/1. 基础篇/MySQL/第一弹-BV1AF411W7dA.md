单表调优


第一点，从我们MySQL表初期设计就要考虑调优。（原因在B+树的高扇出性）

那么设计的时候我们要遵循一个原则。我们的表，每一个字段用多大的量，这个量的上限，一定要严格把控。不能浪费空间，控制单行数据的大小。那么就要说到我们的B+树。

B+树是我们MySQL使用的索引数据的一个存储结构。它是叶子节点、非叶子节点。叶子节点存储整行数据（先以聚簇索引来举例）

聚簇索引就是我们每张表，以我们的MySQL的primary key主键，进行的索引树。

非叶子节点，除了存储八个字节的数据（以bigint 举例），还要存储指针（大小六个字节）。它的非叶子节点要占用14个字节

三层B+树根节点多大呢？16kb

(16 * 1024)/14=1170

我们一个根节点能存储1170 primary key ID+ 1170 指针

到第二层我们就要有1100个节点了，第二层的每一个节点又能存储1100 个ID+1100 个指针。

那么就要来到第三层了。第三层有多少个叶子节点呢？那么就是1100 ^2 吧。这个一百万。也就是说有1百万个叶子节点。

这一百万个叶子节点存储的是我们所有的数据对吧

如果我们没有去规划好它的大小，如果这一条MySQL的数据有16kb的话，那么我们三层高的B+树，只能存储一百万条数据，对吧。

三次IO索引，每次IO索引的时间复杂度是多少。

它是用的二分查找索引的。o(log n)

但是为什么说一有IO索引，时间消耗就特别大呢。

因为它需要加载内存页吧。16kb内存页不是白加载的吧。他把这16kb内存页加载出来。这算一次IO。然后加载完成之后，再进行二分查找，定位我们的Id范围，然后指向二层。指向二层的时候，又要加载一次16kb内存页。

加载完成后，在这16kb里边又要进行二分查找，定位三层。三层又加载一次16kb内存页，再进行二分查找，最终定位数据。

这就多了

# 为啥使用B+树

之前我记得应该用B树，为啥不用二叉树，用hash表也行

B树和B+树的区别，完全在于叶子节点和非叶子节点的存储上。

对于B树来说，每一个节点都要存储MySQL的数据。存储数据量太小

为啥不用二叉树呢？原因一样。B+树不管怎么样。我们是一个多叉树。还不如B树。

刚才还提到了一个hashmap 对吧

为啥不用hashmap?  

1. 支持模糊查询吗？百分号、支持like吗

% 无法计算hashcode, 之前的hashcode不一样

2. 范围查询支持吗？

不行。

id 为1， 做一个hashcode.

id 为2，做一个hashcode.

3. 还有就是hash冲突问题

# 最左前缀原则

like '王%' 找到第一个， 做好了一个排序了。

# 聚集索引

存储主键ID+指针，叶子节点存储的是我们select * 整行的数据

# 辅助索引

辅助索引还是一棵B+树

辅助索引里边，叶子节点会存储主键ID吗？

叶子节点存储的是所有的索引

叶子节点会存储主键id

为什么存主键呢？拿到主键id, 回表查询

辅助索引非叶子节点存储的是什么呢？

指针+索引

辅助索引可以有多个。

# 联合索引

name + age 就是辅助索引，因为没有primary key.

# 哪个列做索引合适

看随机性，随机性越高。

定位为索引，它的效率越高。

布尔值不做索引

date 适合做索引

show index --> cardinality 的一个值 越接近1 离散型越高

cardinality 通过我们的采样算法来说的

## 覆盖索引

具体来说不是索引

以我们的name举例

select * from table where name='XXX' 走的是全表扫描

select name from table where name='xxx'