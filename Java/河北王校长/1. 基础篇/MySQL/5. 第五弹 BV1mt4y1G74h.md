# 互联网企业对于MySQL集群架构的设计

这部分内容涉及分布式

分布式里边又要涉及到读写分离

读写分离是基于复制思想的，复制思想他的核心文件是我们的bin_log

无论你的MySQL集群架构如何设计，他的底层核心技术必然是bin_log的传输，bin_log的读取和写入。

互联网大厂使用的事务的隔离级别是哪种？

RC，Read Commit 

只解决脏读，保留不可重复读和幻读

（不可重复读和幻读）真实反映了数据的变迁，但是违背了事务的隔离级别。

违背了事务的隔离级别，是由于MVCC的出现，他完全的实现形式不一样

而RC读取的是最新的快照，真实反映了当前数据真实的状态。

如果我们不想被其他事务影响，我们是可以在代码层面解决的。

我们可以对前后查询进行幂等校验。我们可以在这种查询下，强制加锁

## RR模式是5.0版本之前的无奈之举

MySQL 5.0 发布大概是在05年

那个时候就会有一部分企业使用到我们的读写分离

或者是所谓的bin_log 的复制技术

bin_log 里面只有一种类型，就是我们的statement 语句

需要将binlog_format 设置为statement，只支持这一种设置

这个binlog会记录我们所有的SQL语句

你是插入、更新都会记录。

但是问题在于我们的企业需要使用RC模式

RC 模式, bin_log在Statement情况下，无法进行一个完美的配合，会导致主库和从库数据不一致的情况。而RR模式可以，保证主从复制他的一个一致性。

只到5.1 版本，因为他非常快呀，没有所谓的间隙锁，他读取最新快照，读取最新的数据。隔离级别越低，他的速度一定是越快的。

在5.1版本引入了所谓的row, binlog_format: row 还引入了mixed (混合模式) 

混合模式是默认情况下，自动能够识别哪些进入ROW，哪些进入我们的statement，但是需要手动修改为ROW的。与我们的RC模式进行配合。

这是所谓的ROW的RBR出现的时间点

> SBR(statement-base replication)
> RBR(row-base replication)
>

SBR 与 RBR的区别，各自的优缺点是什么？

这是八股文出现的时机


大部分互联网企业都是采用RC+RBR模式

那对于Mixed 模式，在RC下，任然只会记录Row模式。因为RC模式配合不了Statement

Statement 限制很多。不能使用uuid等

Row 虽然大，但是可靠。而且大不意味着就慢

这个时候就要提到我们所谓的分布式了。

Row 虽然大，但是可以做项目的分离啊。

不同的项目，使用不同的服务器。

不同的项目，链接不同的MySQL主机。

将我们的项目划分，MySQL数据库划分，MySQL承担的数据业务数据比较少，log增加的也比较少，增加我们的带宽，然后对于我们的读写分离，我们是多主多从。主与主之间互为slave，主服务器下面挂载从服务器。

为什么从服务器下面不挂载服务器？

因为那个东西，很要命。因为会增加中间slave服务器的负担。

**从5.1.22版本有进行了一个非常重要的更新，我们MySQL主键的增长问题。auto_increase_locking和互斥量**


如果我们将MySQL的id自增设为2的话，那么我们所有的插入都会使用互斥量。

那我们在配合我们的RC+bin_log type Row, 就能达到最大效果的数据的插入，以及数据的主从复制。

这个MySQL5.1.22所更新的一个变化。那继续来说MySQL 5.1以后其实，大版本直接就跳到了我们10年的MySQL5.5.

MySQL5.5 依然应对市场的一个变化。大型互联网电商企业起来了，我们MySQL默认采用的读写分离的方式是什么，叫异步复制。

异步复制是什么？ 简单来说就是，我们接到一条写入命令，我们写完之后，直接就返回给我们的客户端。这个时候，一条异步的线程去发起，去进行我们bin_log, 主从同步， 这个时候有一个问题呀。

就是我们异步复制，如果这个bin_log 没有传递到从服务器，已经返回给客户端了。这个时候就会导致主从数据不同步，而且是不可挽回的不同步。

所以MySQL5.5 针对这个复制，他又增加了一个半同步复制。

半同步复制是什么。至少保证

