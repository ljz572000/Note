# Java 并发编程



## 1.1

<br/>

### 1.1.1 Lock 与 Synchronized 的区别

<br/>

Lock 会有放弃加锁的逻辑，Synchronized 没有

先来看下利用synchronized实现同步的基础：

Java 中的每一个对象都可以作为锁。具体表现为以下3种形式。

* 对于普通同步方法，锁是当前实例对象。
* 对于静态同步方法，锁是当前类的Class 对象
* 对于同步方法块，锁是Synchonized括号里配置的对象

<br/>

### 1.1.2 Condition

<br/>

Condition 可以有多个

<br/>

### 1.1.3 可重入锁与不可重入锁

<br/>

<strong>可重入</strong>：同一线程对某一锁多次加锁不会产生死锁

例如:

```java
lock.lock();
lock.lock();
System.out.println(Thread.currentThread().getName());
lock.unlock();
lock.unlock();
```

如果**不可重入**，这段代码就是自己和自己死锁了。

<br/>

### 1.1.4 顺序一致性内存模型

<br/>

当程序未正确同步时，就可能会存在数据竞争。Java 内存模型规范对数据竞争的定 义如下。 

⚫ 在一个线程中写一个变量，

⚫ 在另一个线程读同一个变量， 

⚫ 而且写和读没有通过同步来排序。 

<br/>

**顺序一致性内存模型**有两大特性

<br/>

⚫ 一个线程中的所有操作必须按照程序的顺序来执行。 

⚫ （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。

<br/>

### 1.1.5 避免死锁的方法

<br/>

* 避免一个线程同时获取多个锁
* 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
* 尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制。
* 对于数据库锁，加锁和解锁必须在一个数据库连接李，否则会出现解锁失败的情况。

<br/>

### 1.1.6 锁到底存在哪里呢？锁里面会存储什么信息呢？ 

<br/>

从 JVM 规范中可以看到 Synchonized 在 JVM 里的实现原理，**JVM 基于进入和退出 Monitor 对象来实现方法同步和代码块同步**，但两者的实现细节不一样。**代码块同步是使用 monitorenter 和 monitorexit 指令实现的**，而方法同步是使用另外一种方式实现的，细 节在 JVM 规范里并没有详细说明。但是，**方法的同步同样可以使用这两个指令来实现**。

**monitorenter 指令是在编译后插入到同步代码块的开始位置**，而 **monitorexit 是插入到 方法结束处和异常处**，JVM 要保证每个 monitorenter 必须有对应的 monitorexit 与之配 对。任何对象都有一个 monitor 与之关联，**当且一个 monitor 被持有后，它将处于锁定状 态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即 尝试获得对象的锁**。

<br/>


### 1.1.7 锁的几种状态

<br/>

在 Java SE 1.6 中，锁一共有 4 种状态，级别从低到高依次是：

* 无锁状态
* 偏向锁状态
* 轻量级锁状态
* 重量级锁状态

这几个状态会随着竞争情况逐渐升级。**锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁**。


这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

<br/>

1. 偏向锁 

<br/>

当**一个线程访问同步块并获取锁**时，会在**对象头**和**栈帧**中的锁记录里存储锁偏向的线程 ID，**以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁**，只需简单地测试一下对象 头的 Mark Word 里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获 得了锁。如果测试失败，则需要再测试一下 Mark Word 中偏向锁的标识是否设置成 1 （表示当前是偏向锁）：如果没有设置，则使用 CAS 竞争锁；如果设置了，则尝试使用 CAS 将对象头的偏向锁指向当前线程。 

<br/>

偏向锁的撤销

<br/>

**偏向锁使用了一种等到竞争出现才释放锁的机制**，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。**偏向锁的撤销，需要等待全局安全点**（在这个时间 点上没有正在执行的字节码）

<br/>

关闭偏向锁 

<br/>

**偏向锁在 Java 6 和 Java 7 里是默认启用的**，但是它在应用程序启动几秒钟之后才激活，
如有必要可以使用 JVM 参数来关闭延迟：`-XX:BiasedLockingStartupDelay=0`。
如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过 JVM 参数关闭偏向锁： `-XX:- UseBiasedLocking=false`，那么程序默认会进入轻量级锁状态

2. 轻量级锁

<br/>

加锁

线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空 间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后 线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前 线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

<br/>

解锁

轻量级解锁时，会使用原子的 CAS 操作将 Displaced Mark Word 替换回到对象头， 如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量 级锁。

因为自旋会消耗 CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一 旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程 试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。

<br/>

### 2.3.2 处理器如何实现原子操作

<br/>

处理器提供**总线锁定**和**缓存锁定**两个机制来保证复杂内存操作的原子性

所谓总线锁就是使用处理器提供的一个 LOCK＃ 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存

在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但**总线锁定把 CPU 和内存之间的通信锁住**了，
这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以**总线锁定的开销比较大**，目前**处理器在某些场合下使用缓存锁定代替总线锁定来进行优化**。 


频繁使用的内存会缓存在处理器的 L1、L2 和 L3 高速缓存里，那么原子操作就可以 直接在处理器**内部缓存**中进行，并不需要声明**总线锁**，在 Pentium 6 和目前的处理器中可以使用“**缓存锁定**”的方式来实现复杂的原子性。

所谓“**缓存锁定**”是指内存区域如果被缓存在处理器的缓存行中，并且在 Lock 操作期间被锁定，那么**当它执行锁操作回写到内存** 时，处理器不在总线上声言 LOCK＃信号，而是修改内部的内存地址，并允许它的缓存 一致性机制来保证操作的原子性，因为**缓存一致性机制**会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效

但是有两种情况下处理器不会使用**缓存锁定**。 

**第一种情况**是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存 行（cache line）时，则处理器会调用总线锁定。 
**第二种情况**是：有些处理器不支持缓存锁定。对于 Intel 486 和 Pentium 处理器，就 算锁定的内存区域在处理器的缓存行中也会调用总线锁定。

<br/>

### 2.3.3 Java 如何实现原子操作 

<br/>

在 Java 中可以通过**锁**和**循环 CAS**（compareAndSet）的方式来实现原子操作。

使用循环 CAS 实现原子操作：JVM 中的 CAS 操作正是利用了处理器提供的 CMPXCHG 指令实现的。自旋 CAS 实 现的基本思路就是循环进行 CAS 操作直到成功为止

<br/>

**CAS 实现原子操作的三大问题**

<br/>

ABA 问题，循环时间长开销大，以及只能保证一个共享变量的原子操 作。

**ABA 问题的解决思路就是使用版本号**。在变量前面追加上版本号，每次变量更新的时候把版本号加 1，那么 A→B→A 就会变成 1A→2B→3A。

compareAndSet 方法的作用是**首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值**

<br/>

**使用锁机制实现原子操作**

<br/>

**锁机制保证了只有获得锁的线程才能够操作锁定的内存区域**。JVM 内部实现了很多 种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM 实现锁的方式 都用了循环 CAS，即当一个线程想进入同步块的时候使用循环 CAS 的方式来获取锁， 当它退出同步块的时候使用循环 CAS 释放锁。 


<br/>

### 3.1.1 并发编程模型的两个关键问题


<br/>

在并发编程中，需要处理两个关键问题：**线程之间如何通信**及**线程之间如何同步** （这里的线程是指并发执行的活动实体）。**通信是指线程之间以何种机制来交换信息**。在 命令式编程中，线程之间的通信机制有两种：**共享内存**和**消息传递**。


在**共享内存**的并发模型里，线程之间共享程序的公共状态，**通过写-读内存中的公共状态进行隐式通信**。

在**消息传递**的并发模型里，线程之间没有公共状态，线程之间必须**通过发送消息来显式进行通信**。


**同步是指程序中用于控制不同线程间操作发生相对顺序的机制**。

**在共享内存并发模型里，同步是显式进行的**。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。

在**消息传递**的并发模型里，由于消息的发送必须在消息的接收之前，因此**同步是隐式进行的**。


<mark style="background-color: #FFFF00">Java 的并发采用的是**共享内存模型**，Java 线程之间的通信总是隐式进行，**整个通信过程对程序员完全透明**。</mark>  

<br/>

### 3.1.2 Java 内存模型的抽象结构

<br/>

在 Java 中，**所有实例域、静态域和数组元素**都存储在**堆内存**中，**堆内存在线程之间共享**（本章用“共享变量”这个术语代指实例域，静态域和数组元素）。

**局部变量**（Local Variables），**方法定义参数**（Java 语言规范称之为 Formal Method Parameters）和**异常处理器参数**（ExceptionHandler Parameters）**不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响**。


Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制。

JMM 决定一个线程对共享变量的写入何时对另一个线程可见。

从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：

线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），**本地内存中存储了该线程以读/写共享变量的副本**。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲 区、寄存器以及其他的硬件和编译器优化。

<img src="./images/Java内存模型.png"/>


从图 3-1 来看，如果线程 A 与线程 B 之间要通信的话，必须要经历下面 2 个步骤。 

<br/>

1. 线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。

2. 线程 B 到主内存中去读取线程 A 之前已更新过的共享变量

<br/>

从整体来看，**这两个步骤实质上是线程 A 在向线程 B 发送消息**，而且这个通信过程必须要经过主内存。**JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 Java 程序员提供内存可见性保证**。

<br/>

### 3.1.5 happens-before 简介

<br/>

从 JDK 5 开始，Java 使用新的 JSR-133 内存模型（除非特别说明，本文针对的都是 JSR-133 内存模型）。

<mark>JSR-133 使用 happens-before 的概念来阐述操作之间的内存可见性。 在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系。</mark>

与程序员密切相关的 happens-before 规则如下。 

⚫ 程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续 操作。 

⚫ 监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。 

⚫ volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。 

⚫ 传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。

<br/>

## 3.2 重排序 

<br/>

**重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段**。

<br/>

### 3.2.2 as-if-serial 语义

<br/>

**as-if-serial** 语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单 线程）程序的执行结果不能被改变。编译器、runtime 和处理器都必须遵守 as-if-serial 语义。

<br/>


## 3.3 顺序一致性

顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编 程语言的内存模型都会以顺序一致性内存模型作为参照。

<br/>

### 3.3.1 数据竞争与顺序一致性

<br/>

当程序未正确同步时，就可能会存在数据竞争。Java 内存模型规范对数据竞争的定 义如下。 

⚫ 在一个线程中写一个变量， 

⚫ 在另一个线程读同一个变量， 

⚫ 而且写和读没有通过同步来排序。 

当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果（前一章的示例正 是如此）。

如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。


这里的同步是指广义上的同步，包括对常用同步原语（**synchronized、volatile 和 final）**的正确使用。


顺序一致性内存模型有两大特性。 

⚫ 一个线程中的所有操作必须按照程序的顺序来执行。 

⚫ （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。

在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。

<br/>

### 3.3.3 同步程序的顺序一致性效果

<br/>

## 3.4 volatile 的内存语义

<br/>

### 3.4.1 volatile 的特性 

<br/>

理解 volatile 特性的一个好方法是把**对 volatile 变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步**。

简而言之，volatile 变量自身具有下列特性。


⚫ 可见性。对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量 最后的写入。 

⚫ 原子性：对任意单个 volatile 变量的读/写具有原子性，但类似于 volatile++这种 复合操作不具有原子性。

<br/>


### 3.4.2 volatile 写-读建立的 happens-before 关系

<br/>

从 JSR-133 开始（即从 JDK5 开始），volatile 变量的写-读可以实现线程之间的通信。


从内存语义的角度来说，

* volatile 的写-读与锁的释放-获取有相同的内存效果： 

* volatile 写和锁的释放有相同的内存语义；

* volatile 读与锁的获取有相同的内存语义。

<br/>

### 3.4.4 volatile 内存语义的实现

<img src="./images/3-5.png" />

从表3-5我们可以看出 。 

当 **第二个操作是volatile写**时 ， 不 管 第 一 个 操 作 是 什 么 ， 都 不 能 重 排 序 。 

这 个 规 则 确 保 volatile 写 之 前 的 操 作 不 会 被 编 译 器 重 排 序 到 volatile 写 之 后 。

当 第 一 个 操 作 是 volatile 读 时 ， 不 管 第 二 个 操 作 是 什 么 ， 都 不 能 重 排 序 。 这 个 规 
则 确 保 volatile 读 之 后 的 操 作 不 会 被 编 译 器 重 排 序 到 volatile 读 之 前 。 
当 第 一 个 操 作 是 volatile 写 ， 第 二 个 操 作 是 volatile 读 时 ， 不 能 重 排 序 。 